WEBVTT

00:02.200 --> 00:04.960
What exactly is testing?

00:04.990 --> 00:07.240
Well, we're writing our code, obviously.

00:07.240 --> 00:09.250
That is what we did throughout this course.

00:09.250 --> 00:12.130
And we manually tested this code with that.

00:12.130 --> 00:14.950
I mean, we simply visited the page.

00:14.950 --> 00:17.470
We send requests to our API.

00:17.740 --> 00:23.890
Now, the big advantage of this approach is, of course, that we can see our page, we can really see

00:23.890 --> 00:26.200
the page as our users will see them.

00:26.200 --> 00:32.380
We can interact with our API as any developer would interact with it, and therefore manual testing

00:32.380 --> 00:33.820
is super important.

00:33.910 --> 00:36.040
But there also is a downside.

00:36.070 --> 00:38.620
It's easy to forget to test something.

00:38.620 --> 00:41.170
It's easy to only test some parts.

00:41.170 --> 00:47.560
And especially when you make changes to your code, it's easy to break something in some place of your

00:47.560 --> 00:53.380
app, which you might not think you're breaking and you're not testing it explicitly, and therefore

00:53.410 --> 00:58.420
you introduce a bug which you only find later or maybe never at all.

00:58.600 --> 01:06.550
That, of course, is the downside, and it's pretty hard to test every possible feature and every possible

01:06.550 --> 01:12.070
combination of steps in your application after every tiny change you make.

01:12.220 --> 01:15.340
And that is where automated testing comes into play.

01:15.610 --> 01:20.800
Automated code testing means that we write code that tests our code.

01:20.800 --> 01:28.060
So we define steps that are executed, we define certain scenarios that are tested, and we automatically

01:28.060 --> 01:34.870
run these tests on every change or after every important change we made so we can run them whenever

01:34.870 --> 01:35.530
we want.

01:35.530 --> 01:42.220
We can even put them into our deployment process and run them right before our app gets deployed and

01:42.220 --> 01:46.600
Dad will throw an error at us whenever some of our tests fail.

01:46.600 --> 01:52.000
And we can then look into these tests and find out why they failed and fix them.

01:52.420 --> 01:58.660
The big advantage of automated testing, therefore, of course, is that we can cover all core features

01:58.660 --> 02:04.480
and we can define all possible scenarios you want to test and therefore really make sure that we don't

02:04.480 --> 02:06.100
introduce breaking changes.

02:06.220 --> 02:09.430
But of course there are downsides to automated testing too.

02:09.580 --> 02:15.190
If you write the wrong tests, then you might have a good feeling because all your tests are passing,

02:15.190 --> 02:19.090
but maybe you're just testing for the wrong things, for the wrong scenarios.

02:19.420 --> 02:25.570
Additionally, well, you only test what you define and it's also hard to test the user interface,

02:25.570 --> 02:29.680
so you might not really see what your users see.

02:29.680 --> 02:35.890
So it's a combination of both manual testing, which we did throughout the course and which you naturally

02:35.890 --> 02:40.360
do, and automated testing what you'll learn about in this module.
