WEBVTT

00:02.620 --> 00:04.910
We have the create user schema,

00:04.930 --> 00:11.350
let's now work on a resolver that allows us to create a user and for that in the resolvers file, I'll add

00:11.770 --> 00:14.220
create user like that

00:14.410 --> 00:17.700
and now here I actually get some arguments,

00:17.740 --> 00:21.130
you also do so in queries where you get data by the way,

00:21.190 --> 00:26.290
there you could also get arguments for example when you want to retrieve a specific post with a specific

00:26.290 --> 00:27.180
ID.

00:27.350 --> 00:29.660
Here my arguments are no post ID though

00:29.770 --> 00:31.490
but the user input data.

00:31.750 --> 00:34.900
My first argument there will be an args object,

00:34.900 --> 00:38.940
there is a second argument available which is the request by the way,

00:39.070 --> 00:47.410
this will become important later. Now on the incoming args object, I can retrieve all the data I defined

00:47.410 --> 00:48.240
in my schema,

00:48.340 --> 00:52.150
so email, name and password, that is my argument data

00:52.180 --> 00:55.440
so that is what I can retrieve from the args object.

00:55.570 --> 00:57.550
Not directly on the args though,

00:57.550 --> 01:03.940
instead args will have a user input field because args actually will be an object containing all the

01:03.940 --> 01:05.990
arguments passed to that function,

01:06.010 --> 01:08.050
here it's only one but it could be more,

01:08.170 --> 01:14.770
so args will have a user input field and in there, I will have email, name and password. So I can retrieve

01:14.770 --> 01:15.090
them,

01:15.100 --> 01:22.760
I can for example retrieve my email by typing args user input because in my schema, I name this field

01:22.760 --> 01:27.600
here user input and on the user input, I can get the email,

01:27.700 --> 01:30.960
so .email like this.

01:31.050 --> 01:32.320
This is one option,

01:32.490 --> 01:39.330
we can also use destructuring to get user input out of my args object

01:39.330 --> 01:45.880
and then the email will just be user input email,

01:45.890 --> 01:49.550
so a bit shorter. Now we'll use this in a second,

01:49.550 --> 01:52.860
first of all let's import the mongoose user model

01:52.910 --> 01:55.400
because I'll still interact with the database of course.

01:55.730 --> 02:06.490
So I will require models user and then in here, I want to use the async await syntax, to use that I

02:06.490 --> 02:09.230
need to change the way I write this method.

02:09.430 --> 02:13.600
I add a colon after create user and use the function keyword

02:13.600 --> 02:16.440
and now I can add async in front of that.

02:16.840 --> 02:20.310
So now I can use async await, that is purely optional though,

02:20.380 --> 02:26.800
you could also use the normal then catch approach with your promises. Now in there,

02:26.860 --> 02:33.790
first of all I want to find out if that user already exists and for that, I'll get an existing user by

02:33.790 --> 02:43.030
awaiting for user find one where the email in the database matches the email entered in the user

02:43.030 --> 02:43.820
input.

02:44.200 --> 02:52.060
Now one super important note, if you're not using async await, you need to return your find one query

02:52.060 --> 02:57.250
which you're executing here where you then add then because if you don't return your promise in the

02:57.250 --> 03:03.970
resolver, graphql will not wait for it to resolve. When using async await, it's automatically returned

03:03.970 --> 03:04.750
for you,

03:04.780 --> 03:07.520
we don't see the return statement here but it is there,

03:07.720 --> 03:09.240
so that is super important.

03:10.050 --> 03:16.450
So now I'm getting my existing user and if I have an existing user, well then I know I don't want to

03:16.450 --> 03:17.910
create a new one.

03:17.920 --> 03:29.540
So in this case, I will create a new error with a message of user exists already and I will throw that

03:29.540 --> 03:34.900
error and I will come back to error handling and graphql in a later lecture.

03:35.540 --> 03:40.520
If I do have no existing user with that email address,

03:40.520 --> 03:46.280
then I can continue with storing it and the logic for that is similar to the one in my auth controller,

03:46.280 --> 03:49.760
we need bcrypt to hash the password.

03:49.760 --> 03:59.400
So in my resolver function here, let me import bcrypt at the top and then there, we can use the hash

03:59.520 --> 04:08.180
method to hash the user input password with 12 salting rounds.

04:08.190 --> 04:10.140
Now again I'll use async await here,

04:10.350 --> 04:15.690
so I'll get my hashed password eventually after awaiting for this to finish.

04:16.780 --> 04:26.230
Now after I got that, I can create a new user object and in that user object, I will pass the email which

04:26.230 --> 04:33.010
is user input email, I'll pass the name which is user input name,

04:33.050 --> 04:37.940
I'll also pass the password which is my hashed password.

04:37.970 --> 04:45.620
Now I need to save that to the database and I do care about the created user, so I'll store that, stored

04:45.620 --> 04:55.420
all that created user in a constant by awaiting for a user save and that will just return that

04:55.600 --> 04:56.320
user object

04:56.320 --> 05:04.440
I created. Now here finally I need to return some data and we see which data in our schema, we need to

05:04.440 --> 05:05.790
return a user object.

05:08.160 --> 05:17.450
For that here, I will return my created user_doc field which contains just the user data without

05:17.480 --> 05:18.310
all the metadata

05:18.320 --> 05:24.380
mongoose would add otherwise and I will override the _id field by adding it as a separate

05:24.380 --> 05:28.930
property and therefore it will override the one I'm pulling out of

05:29.000 --> 05:34.450
_doc because I need to convert it from an object id field to a string field

05:34.550 --> 05:36.230
otherwise it will fail,

05:36.350 --> 05:43.210
so here I will access created user _id and then call toString.

05:43.220 --> 05:44.490
This is now the user object

05:44.520 --> 05:47.430
I'm returning when I'm creating a user.

05:47.560 --> 05:52.740
Now one important note before we actually try that in our frontend application.

05:53.140 --> 06:00.130
We can of course try that from inside postman but there is an even more convenient solution for testing

06:00.130 --> 06:02.830
this. Before I show you the solution,

06:02.830 --> 06:05.040
let me first of all clean my database though

06:05.110 --> 06:06.780
so that we start from scratch

06:07.000 --> 06:11.850
and before that, I'll delete both my posts and my users collection here.

06:12.010 --> 06:14.040
It will be created on the fly again

06:14.050 --> 06:19.730
once I got data to enter and I simply want to remove all entries I have thus far.

06:19.780 --> 06:21.510
So now with the clean database,

06:21.550 --> 06:27.550
let me show you that simpler approach I'm referring to. To test this mutation,

06:27.550 --> 06:34.920
I can go back to app.js on the backend code and there where I register or setup my graphql

06:35.000 --> 06:38.940
endpoint, besides setting the schema and root value,

06:38.950 --> 06:44.590
you can also set graphiql, written graphiql to true.

06:44.920 --> 06:50.080
This gives you a special tool and this is the reason why I'm not listening for post requests only

06:50.080 --> 06:53.720
here because now with your running server,

06:53.890 --> 07:00.910
try visiting localhost8080/graphql and this will send a get request, if you enter something in

07:00.910 --> 07:06.940
the browser here here, you sent a get request and you will get this screen which allows you to play around

07:06.940 --> 07:08.790
with your graphql API.

07:09.070 --> 07:17.040
Now if you go back to your backend, to the schema, quickly add a query again to your schema here, root

07:17.530 --> 07:18.010
query and let's

07:20.680 --> 07:27.350
create that type here real quick and in there, just add that hello again like this.

07:27.350 --> 07:28.730
We don't need a resolver for that,

07:28.730 --> 07:30.220
we just need that query.

07:30.380 --> 07:36.410
Now if you reload your graphiql interface, you actually have that documentation on the right here where

07:36.410 --> 07:42.290
you see the operations you can do but you need to have a query defined for that, even if it leads into

07:42.290 --> 07:43.280
the void

07:43.340 --> 07:50.030
and there you can click onto it to see which mutations you have, which data you need to send and so on

07:50.510 --> 07:52.320
and you can not just explore that here,

07:52.340 --> 07:58.770
you can even send your data. So in here, you can now create a new mutation about typing mu and you

07:58.770 --> 08:01.130
will even get autocompletion,

08:01.130 --> 08:04.910
then curly braces and now with control space,

08:05.010 --> 08:09.840
you even get suggestions, if you have more than one object, it will not be filled in automatically but you'll

08:09.860 --> 08:11.510
get a dropdown instead,

08:11.510 --> 08:15.270
you get suggestions for what you can run and here you now see

08:15.280 --> 08:20.660
this needs a user input then a colon and then an object that contains the user input data

08:20.960 --> 08:25.150
and there you see we need an email wrapped in double quotation marks,

08:25.150 --> 08:26.060
test@test.com,

08:26.060 --> 08:36.060
we let's say need a name, that could be max and we need the password and that is tester and thereafter

08:36.080 --> 08:38.010
we add a pair of curly braces

08:38.120 --> 08:43.220
and now we can define the data we want to return after this query is done. With control space

08:43.220 --> 08:44.400
we get some suggestions,

08:44.450 --> 08:51.860
like the ID that was generated or the email. And now you can run this query by pressing that play button

08:51.860 --> 08:54.500
up there or hitting control enter,

08:54.510 --> 08:56.180
you also see the commands here

08:57.780 --> 09:01.180
and this will now execute it and it seemed to have succeeded.

09:01.380 --> 09:07.290
You see the ID of the created user and the email and if you go back to mongodb compass and you

09:07.320 --> 09:08.250
refresh that

09:08.250 --> 09:14.470
here, you should have the users collection back and you see the user in there with the hashed password.

09:14.550 --> 09:20.700
So this is a great tool for playing around, better than postman because you got this nice interactive

09:20.700 --> 09:22.860
support with the auto-completion,

09:22.890 --> 09:29.310
you've got the documentation here and you can test your graphql query in this tool in a really nice

09:29.310 --> 09:29.980
way.

09:30.360 --> 09:37.550
And now with that, let's see how we can enhance this for example by adding validation before we then

09:37.560 --> 09:40.200
also connect our frontend application of course.
