WEBVTT

1
00:00:02.120 --> 00:00:03.970
<v Narrator>Now in our TypeScript code,</v>

2
00:00:03.970 --> 00:00:06.070
we have some repetition.

3
00:00:06.070 --> 00:00:08.550
Not horrible and definitely bearable,

4
00:00:08.550 --> 00:00:10.690
but we have some repetition and some code

5
00:00:10.690 --> 00:00:12.300
that could be hard to read.

6
00:00:12.300 --> 00:00:14.610
For example here we have repetition,

7
00:00:14.610 --> 00:00:18.230
we re-use the same union type in two places.

8
00:00:18.230 --> 00:00:20.440
Now, this is definitely okay,

9
00:00:20.440 --> 00:00:22.140
but you could optimize this

10
00:00:22.140 --> 00:00:24.910
or improve this with a type alias.

11
00:00:24.910 --> 00:00:28.150
TypeScript has a built in type operator,

12
00:00:28.150 --> 00:00:30.510
which does not exist in JavaScript,

13
00:00:30.510 --> 00:00:34.120
don't confuse it with type of, type is a different one.

14
00:00:34.120 --> 00:00:37.630
This allows you to set up your own type alias

15
00:00:37.630 --> 00:00:40.370
so you can give a different type a new name.

16
00:00:40.370 --> 00:00:42.280
And that is especially useful

17
00:00:42.280 --> 00:00:45.140
if you're working with union types for example.

18
00:00:45.140 --> 00:00:49.410
We can have our num or string type for example,

19
00:00:49.410 --> 00:00:52.040
the name is up to you, you could name it like this,

20
00:00:52.040 --> 00:00:55.490
and the value which we store in there is now a type.

21
00:00:55.490 --> 00:00:57.520
So for example this union type.

22
00:00:57.520 --> 00:01:01.700
And now we can use num or string in all the places

23
00:01:01.700 --> 00:01:04.380
where we previously set up the union type.

24
00:01:04.380 --> 00:01:09.280
And you can store anything, any type in such a type alias.

25
00:01:09.280 --> 00:01:13.780
Now if you compile this, if you compile this code,

26
00:01:13.780 --> 00:01:16.530
this will be gone, you don't see the type alias there

27
00:01:16.530 --> 00:01:19.060
because it's a pure TypeScript feature.

28
00:01:19.060 --> 00:01:21.670
But it can save you some repetition.

29
00:01:21.670 --> 00:01:24.020
You can also use the type alias

30
00:01:24.020 --> 00:01:26.910
to for example store your object type.

31
00:01:26.910 --> 00:01:31.060
My result, and again that name is up to you,

32
00:01:31.060 --> 00:01:33.690
could be this object type.

33
00:01:33.690 --> 00:01:36.290
So I can cut it from down there,

34
00:01:36.290 --> 00:01:38.793
and now use result down there.

35
00:01:39.890 --> 00:01:41.793
And now I'm referring to this object.

36
00:01:45.110 --> 00:01:47.980
So type aliases can be very useful.

37
00:01:47.980 --> 00:01:51.030
An alternative, at least when you're working with

38
00:01:51.030 --> 00:01:54.410
object types are interfaces.

39
00:01:54.410 --> 00:01:56.450
Interfaces also allow you

40
00:01:56.450 --> 00:01:59.530
to define the structure of an object.

41
00:01:59.530 --> 00:02:04.260
For example result object, to avoid a name clash.

42
00:02:04.260 --> 00:02:07.640
Here I could paste in that exact same structure

43
00:02:07.640 --> 00:02:10.490
as for my result type alias.

44
00:02:10.490 --> 00:02:13.140
And I can now use result object

45
00:02:13.140 --> 00:02:15.800
where I previously used result.

46
00:02:15.800 --> 00:02:17.910
Now why would you use an interface

47
00:02:17.910 --> 00:02:20.810
or a type alias, what's the difference?

48
00:02:20.810 --> 00:02:23.330
If you're just defining the structure of an object,

49
00:02:23.330 --> 00:02:25.060
you can use either of the two.

50
00:02:25.060 --> 00:02:27.180
Using interfaces is a bit more common

51
00:02:27.180 --> 00:02:28.830
but it's not a must to.

52
00:02:28.830 --> 00:02:33.470
Interfaces can however also be used to force classes

53
00:02:33.470 --> 00:02:36.690
to implement certain methods or functionalities,

54
00:02:36.690 --> 00:02:39.910
but that's beyond the scope of this basics refresher,

55
00:02:39.910 --> 00:02:41.120
you do learn about it

56
00:02:41.120 --> 00:02:44.000
in my understanding TypeScript course though.

57
00:02:44.000 --> 00:02:47.493
So for basic type aliasing, it doesn't matter.

58
00:02:48.410 --> 00:02:52.570
So, here we have a type alias, here we have the interface.

59
00:02:52.570 --> 00:02:54.780
A last important note is that

60
00:02:54.780 --> 00:02:58.970
if you would add your own class or constructor function,

61
00:02:58.970 --> 00:03:02.060
you could use the class name as a type as well,

62
00:03:02.060 --> 00:03:04.060
just as we're using date here.

63
00:03:04.060 --> 00:03:07.120
We can use date with new date

64
00:03:07.120 --> 00:03:10.990
to instantiate it and get the current date time stamp,

65
00:03:10.990 --> 00:03:13.690
but we can also use it just as a type.

66
00:03:13.690 --> 00:03:17.130
And that's true for any constructor function and class,

67
00:03:17.130 --> 00:03:20.123
no matter if it's a built in one, or your own one.

