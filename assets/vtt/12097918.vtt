WEBVTT

00:02.910 --> 00:08.150
So we're at the point where we know that the user did enter valid credentials,

00:08.160 --> 00:11.110
now we want to use that information to generate such a

00:11.160 --> 00:16.900
json web token which I showed you on the slides. For that let's quit the server here,

00:16.930 --> 00:17.840
the node server

00:17.990 --> 00:21.330
and let's install a new package, the package

00:21.350 --> 00:24.880
I want to use is called jsonwebtoken,

00:24.950 --> 00:31.080
one word, this is a package which allows us to conveniently create such new json web tokens.

00:31.460 --> 00:33.570
We can now restart a server

00:33.770 --> 00:36.650
and we need to import this into this file,

00:36.680 --> 00:42.010
so here, I'll import it, store it in a constant named jwt, the name is of course up to you

00:42.410 --> 00:48.080
the json web token package or the object it exposes. Now down there

00:48.110 --> 00:55.490
after checking the password, I want to generate a new token stored the token and I'll store the constant named token

00:56.180 --> 01:00.000
and then here I'll use the jwt package and there the sign method,

01:00.080 --> 01:08.530
this creates a new signature and packs that into a new json web token. We can add any data we want into

01:08.530 --> 01:12.190
the token, like for example we could store the user email,

01:12.190 --> 01:19.270
so access the loaded user e-mail and the user id, access the loaded user _id

01:19.330 --> 01:25.080
and since it's a mongodb object ID here, let's convert that to a string.

01:25.350 --> 01:27.540
So now I'm storing some user data in the token,

01:27.580 --> 01:32.350
of course you should not store the raw password in here because that would be returned to the frontend,

01:32.350 --> 01:39.760
to the user to whom the password belongs but still not ideal, email and user ID should be fine however

01:40.580 --> 01:48.480
and then you need to pass a second argument which is that secret, so that private key which is used for

01:48.480 --> 01:55.060
signing and that is now only known to the server and therefore you can't fake that token on the client.

01:55.300 --> 01:56.910
I'll enter secret here,

01:56.930 --> 02:05.240
typically you want to use a longer string like some super secret secret or even longer,

02:05.240 --> 02:11.840
also check out the official docs of the json web token to learn more about it all. I'll

02:11.870 --> 02:18.130
also set a third argument where I configure this and there, I'll set an expiry time of one hour with this

02:18.140 --> 02:21.920
syntax so that the token becomes invalid after one hour.

02:21.920 --> 02:26.990
Now this is a security mechanism you should add because the token is stored in the client,

02:26.990 --> 02:33.740
now of course by the client to whom it belongs but technically, that token could be stolen. If the user

02:33.740 --> 02:40.310
does not logout, another person copies the token from his browser storage and then he can use it on his

02:40.310 --> 02:41.850
own PC forever.

02:42.020 --> 02:46.770
Well not forever now at least because after one hour, the token becomes invalid,

02:46.910 --> 02:55.400
so this is a good security mechanism which is like a nice, finds a nice balance between usability where

02:55.400 --> 03:01.960
you would want infinite sessions and security where you would want to limit this to like one second.

03:02.090 --> 03:06.660
Now this is all a nice in-between solution which is pretty common.

03:07.010 --> 03:10.810
So now we have a token which we can return to the client,

03:10.820 --> 03:17.700
so here indeed I will now return a response with status code 200 where I add some data,

03:18.650 --> 03:27.140
we can add a message if you want but I will only add that token which I generated and a user ID and

03:27.140 --> 03:35.270
that is my loaded user ._id toString. Now that data needs to be provided because in the

03:35.270 --> 03:35.880
react app

03:35.930 --> 03:36.810
I gave you,

03:36.890 --> 03:41.350
I'll be looking for that ID and I'll be storing it, by the way you should also take one hour

03:41.360 --> 03:48.200
because in that react app, I'll log you out after one hour and all that storing and so on will be done

03:48.250 --> 03:49.840
by the frontend,

03:49.880 --> 03:53.390
now I'll show you how it gets stored in a second of course.

03:53.390 --> 04:00.560
So let's now go back to our auth route and connect our login route to our auth controller and there, the

04:00.560 --> 04:02.440
login action

04:02.630 --> 04:08.170
and now with that, let's go back to the frontend and work on the code there as well.

04:08.390 --> 04:12.790
So in the frontend here in the app.js file where we have the sign up handler,

04:12.830 --> 04:19.230
we have to look for the login handler here and we should fix the url there

04:19.230 --> 04:25.790
too, the url is localhost 8080/auth/login,

04:25.790 --> 04:32.660
we need to pass an object where we now also change the request method to post and where we pass our

04:32.660 --> 04:33.800
data.

04:33.800 --> 04:40.010
So just as with signing up, we can actually copy that logic from there, the headers and the body, copy

04:40.010 --> 04:43.130
that and move it to login,

04:43.130 --> 04:45.700
we don't pass the name in the body though

04:45.800 --> 04:47.890
but password and email will be passed.

04:47.900 --> 04:51.050
Now there is another small adjustment required, here

04:51.110 --> 04:57.770
you can actually directly access auth data e-mail and auth data password.

04:57.770 --> 05:03.770
Now with that, save that and go back to your react app and try logging in with the credentials you created

05:03.770 --> 05:05.190
a couple of lectures ago.

05:06.060 --> 05:06.970
It should work,

05:06.990 --> 05:10.000
this error still is coming from the status which we'll fix soon

05:10.350 --> 05:17.100
and here we also see that I'm logging something, we see that token that was generated and the user ID.

05:17.960 --> 05:23.940
In your chrome browser dev tools, you can also go to the application tab and there go to the local storage,

05:24.090 --> 05:28.450
select your domain and you will see that token here,

05:28.620 --> 05:31.230
that is the token we generated on the server.

05:31.980 --> 05:39.240
The other data is data I'm storing here or that was stored way back by other application so we don't need that,

05:39.240 --> 05:40.780
that has nothing to do with our app.

05:40.950 --> 05:43.980
We have the expiry date which I generated on the client

05:43.980 --> 05:49.580
to know when I should remove the token because it expired and this is the token itself.

05:49.580 --> 05:56.310
Now you can also take that token and visit jwt.io, there you can learn more about json web

05:56.310 --> 06:02.850
tokens first of all and you can also paste your token into that area on the left

06:03.000 --> 06:10.110
and this allows you to look into your token, you don't see your secret but you can now validate it.

06:10.190 --> 06:22.080
If you enter your secret which you chose on the server, some super secret secret, then you should end

06:22.080 --> 06:24.560
up with that same token you copied in

06:24.570 --> 06:27.200
and indeed if I replace it, it does not change.

06:27.240 --> 06:31.570
And here you also see that payload data you added on your server side,

06:31.650 --> 06:34.790
you could theoretically extract that on the client too

06:34.920 --> 06:38.460
and that is why you should not store super sensitive data in there

06:38.580 --> 06:44.640
but this now also shows you that if I try to generate this token on my own, let's say I also edit it like

06:44.760 --> 06:50.850
change the email address, the token changes on the left and therefore if I edit this, it will not be validated

06:50.910 --> 06:57.360
because now the token is not the same as it was when it was generated on the server with this secret.

06:57.360 --> 07:02.520
So if I try to generate my own one with a different secret, I'll end up with a different token and if

07:02.520 --> 07:08.290
I try to edit the data in there, I also do so I can't mess around with the token in the client,

07:08.400 --> 07:15.150
the server will detect this. This is how we can login and how we work with tokens to know whether we

07:15.150 --> 07:16.210
are logged in.

07:16.440 --> 07:19.360
We're missing one important piece of information though,

07:19.740 --> 07:21.150
we have the token,

07:21.150 --> 07:27.840
now we also need to attach the token to requests that require authentication because right now,

07:27.990 --> 07:34.890
well I am logged in, I only see these options after logging in but theoretically deleting, editing and

07:34.890 --> 07:39.290
so on does not really care about the token. We should change this,

07:39.300 --> 07:47.550
we should also connect new posts to our user and we should make sure that only users who created a post

07:47.730 --> 07:49.660
can edit or delete it.

07:49.680 --> 07:51.100
So still some work to do.
