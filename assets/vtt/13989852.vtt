WEBVTT

00:02.140 --> 00:07.540
Of course, it's now important to point out that these tests are totally redundant.

00:07.660 --> 00:11.410
We're not testing our code, not our application code.

00:11.410 --> 00:16.990
At least we're testing some dummy code and we're defining everything our test relies on directly in

00:16.990 --> 00:17.580
the test.

00:17.590 --> 00:22.900
Therefore, this test runs stand alone, totally detached from our application.

00:22.900 --> 00:29.200
And whether the test succeeds or fails, it only depends on the testing code itself, which of course

00:29.200 --> 00:31.240
is a test you should omit.

00:31.240 --> 00:33.730
It's not a helpful test.

00:33.730 --> 00:35.410
This is just some JavaScript code.

00:35.410 --> 00:41.650
You're running nice if you have too much time to spend, but certainly not helpful in reality.

00:41.650 --> 00:47.800
You want to test your application code and you want to test code that's not entirely defined here in

00:47.800 --> 00:48.670
your tests.

00:48.670 --> 00:53.110
Instead, in your tests you typically only define your success condition.

00:53.110 --> 00:59.110
You can, by the way, also have multiple success conditions, multiple expectations, and you might

00:59.110 --> 01:02.230
define any additional setup you need for that test.

01:02.230 --> 01:08.920
For example, user input, you're assuming for this test to simulate different scenarios, but you don't

01:08.920 --> 01:13.660
want to have the actual code or the actual behavior you're testing in your test.

01:13.660 --> 01:15.730
That is not the idea.

01:15.970 --> 01:20.590
And therefore, let's get rid of these dummy tests here.

01:20.590 --> 01:26.890
I'll simply comment them out and let's write a more realistic, a more helpful test.

01:27.530 --> 01:29.150
Now, what could that be?

01:29.180 --> 01:35.540
Let's have a look at our middleware at our is off middleware and let's maybe test something related

01:35.540 --> 01:37.630
to this function we're exporting here.

01:37.640 --> 01:42.860
We're exporting a middleware function and in the end we could test all kinds of things there.

01:42.890 --> 01:51.620
So let's add a new file in the test folder D off middleware JS file, for example, and you can name

01:51.620 --> 01:53.060
this whatever you want, of course.

01:53.270 --> 01:57.440
And here I now want to import this function and then test it.

01:57.710 --> 02:05.930
So I'll import my off middleware by requiring it, of course from the middleware folder from the is

02:05.930 --> 02:06.950
off file.

02:06.950 --> 02:08.960
And then again we define a test.

02:08.990 --> 02:10.610
Now what could we test here?

02:10.850 --> 02:14.720
There's a bunch of stuff we can test and we will test different things here.

02:14.810 --> 02:21.500
But the first simple test could be that we want to make sure that we really get an error whenever.

02:22.480 --> 02:25.840
This year does not have an authorization header.

02:26.370 --> 02:32.010
So back of the off middleware GS file where we define a test, we put the final test where it say it

02:32.010 --> 02:39.720
should throw an error if no authorization header is present.

02:40.000 --> 02:42.900
This is a valid description for our test here.

02:43.260 --> 02:48.270
And then I'll add a function where we actually add our testing code.

02:48.630 --> 02:56.220
And now we of course want to call our off middleware manual here because we're not simulating a full

02:56.220 --> 03:02.430
request flow, we're not simulating a click of the user, which then sends a request, which then triggers

03:02.430 --> 03:03.260
the middleware.

03:03.270 --> 03:05.610
We just want to test our middleware function.

03:05.880 --> 03:08.610
This is called a unit test, by the way.

03:08.640 --> 03:13.830
We test one unit of our application in this case, that is this function.

03:13.830 --> 03:16.440
Typically a unit is a function here.

03:16.440 --> 03:23.910
It's this middleware function integration test would be where we test a more complete flow, so where

03:23.910 --> 03:30.930
we maybe test whether the request is routed correctly and then all to the middleware and then also the

03:30.930 --> 03:32.520
controller function.

03:32.520 --> 03:39.000
But you don't test that too often because it's very complex to test such long chains.

03:39.000 --> 03:45.300
There are multiple things that could fail, and by writing unit tests, it's way easier to test different

03:45.300 --> 03:46.830
scenarios for each unit.

03:46.830 --> 03:52.110
And if all your unit tests succeed, you have a great chance of your overall application.

03:52.110 --> 03:55.590
Working correctly and therefore writing unit tests is very helpful.

03:55.590 --> 04:00.000
If a unit test fails, it's all too easy to find out why it failed.

04:00.030 --> 04:04.740
If you have a lot of steps in, Wolf, that might be harder to find out which step failed.

04:05.280 --> 04:08.040
So we're testing this middleware function only.

04:08.040 --> 04:13.830
And that, of course, means that we have to create a dummy request object we pass in, because normally

04:13.830 --> 04:17.520
that's passed in by the Express middleware, just like response and next.

04:17.520 --> 04:23.880
But now since we're directly calling our middleware function, we want to define our own request object.

04:23.880 --> 04:27.870
And that is actually great because that allows us to define different scenarios.

04:28.020 --> 04:36.690
So here I can create a request object and that object here should have a get functional because in the

04:36.690 --> 04:43.620
off middleware, I'm calling this get function here and this get function now in reality returns the

04:43.620 --> 04:46.160
value of the authorization header.

04:46.170 --> 04:51.420
Now in reality, this get method here provided by express is way more complex.

04:51.420 --> 04:57.840
Of course it does not only scan headers, it scans different parts of the incoming request, but our

04:57.840 --> 05:03.630
goal now is not to replicate the express framework, but to test one specific scenario.

05:03.660 --> 05:10.560
And here the scenario is that get authorization does not return an authorization header because that

05:10.560 --> 05:14.130
is what we want to test here, that in this case we throw an error.

05:14.520 --> 05:18.330
So here function dysfunction should simply return null.

05:18.330 --> 05:24.330
This means it does not return a value for our authorization call here.

05:24.420 --> 05:30.270
Now of course here we pass an authorization string to the get method here.

05:30.270 --> 05:31.950
I'm not expecting this argument.

05:31.950 --> 05:33.660
You could, of course add it here.

05:33.660 --> 05:37.050
You could expect your header name or whatever you want to call it.

05:37.050 --> 05:38.820
But I don't really care about this.

05:38.820 --> 05:45.480
I know that the code I want to test calls to get method and I know that I want to return null to simulate

05:45.480 --> 05:50.760
that there is no authorization header because I of course know the code I'm testing and I want to test

05:50.760 --> 05:56.610
different scenarios and this is how you have to think about testing your testing different scenarios.

05:56.610 --> 06:03.390
You're not trying to rebuild the framework you're using, you're not trying to rebuild some complex

06:03.390 --> 06:04.620
functionality.

06:04.620 --> 06:08.400
You want to force your code into certain scenarios.

06:08.400 --> 06:10.620
You want to test them under certain scenarios.

06:10.620 --> 06:17.040
And here the scenario is that the get method on the request object returns null no matter what it does

06:17.040 --> 06:17.940
in reality.

06:18.540 --> 06:20.250
So here we return.

06:20.250 --> 06:25.710
NULL, which of course could be the case if in our real app that really runs, we get a request where

06:25.740 --> 06:27.480
no authorization header is set.

06:27.480 --> 06:30.300
In this case, this would all the returned null or undefined.

06:30.300 --> 06:31.920
So here we return null.

06:32.070 --> 06:38.490
Now we can call off middleware and pass in our own request object here, which has nothing else.

06:38.490 --> 06:39.750
It has nothing else.

06:39.750 --> 06:45.030
The request object normally has, but it has everything we need for this test there.

06:45.030 --> 06:48.510
We only need this get method and it has that.

06:48.990 --> 06:54.900
Now for the response object we can pass in an empty dummy object because we're not testing anything

06:54.900 --> 06:59.970
related to this response object and the code we're testing all that doesn't rely on it.

06:59.970 --> 07:03.030
It doesn't even use the response object in this entire function.

07:03.030 --> 07:08.430
And therefore we don't need to spend any time on adding any logic to this response object.

07:08.730 --> 07:14.160
And now the next function which is called at the end, well, we want to pass it in, but we don't care

07:14.160 --> 07:19.530
about what it does because we're not really executing our next step here anyways.

07:19.530 --> 07:25.620
So here I'll just pass in an empty arrow function so that it is able to call that without.

07:25.690 --> 07:31.600
Brilliant error, but that it also doesn't do anything because it's again, not what I want to test.

07:31.630 --> 07:35.290
I only want to test the behaviour when get returns null.

07:35.890 --> 07:37.030
So now we're calling this.

07:37.030 --> 07:39.460
But of course we wanted to test something, right.

07:39.610 --> 07:51.010
So let's now import expect again by requiring Chae and then expect and now let's expect the result of

07:51.010 --> 07:52.810
that off middleware call here.

07:52.810 --> 08:01.690
So of that entire call to be something where in this case to throw that's all the just in our utility

08:01.690 --> 08:07.390
method you have here you can find this in the official docs of course here if you scroll down or if

08:07.390 --> 08:11.380
you as I do here, search for flow, you'll find detailed explanation.

08:11.380 --> 08:19.120
So now here I expect this function call for a request that returns null when we try to get something

08:19.120 --> 08:23.350
for a given header name, I expect that to throw.

08:24.290 --> 08:26.570
An error with the message.

08:26.570 --> 08:32.210
And now the message, of course, is to find in our real code we should have a message of not authenticated.

08:32.210 --> 08:34.400
So this exact message here.

08:34.430 --> 08:37.100
So I expect this to be thrown.

08:40.390 --> 08:44.470
Now let's rerun NPM test here.

08:45.430 --> 08:46.180
And.

08:46.860 --> 08:48.240
I actually get an error.

08:48.660 --> 08:51.150
And that, of course, is strange.

08:51.480 --> 08:54.750
Why am I getting the error I'm trying to test for?

08:54.780 --> 08:58.640
Actually, this should pass without an error because the function frozen error.

08:58.650 --> 09:00.000
Because that's what I'm expecting.

09:00.690 --> 09:01.950
Well, the reason is simple.

09:02.130 --> 09:07.590
I am calling my middleware function here, and this middleware function just happens to throw an error.

09:07.950 --> 09:10.260
I don't want to call it myself.

09:10.260 --> 09:12.750
I want to let my testing framework.

09:12.750 --> 09:14.820
So I want to let Mocha and Chai.

09:14.850 --> 09:15.690
These two tools.

09:15.690 --> 09:20.950
I want to let these call this function for me so that they can handle the in error.

09:20.970 --> 09:25.380
Here I would have to handle it myself and that would defeat the entire purpose of testing this.

09:25.530 --> 09:32.490
So instead of calling off middleware directly ourselves here, we instead only pass a reference to this

09:32.490 --> 09:40.980
function here to our expected function, and we only want to bind the arguments we eventually want to

09:40.980 --> 09:43.560
pass in when our testing set up calls.

09:43.560 --> 09:51.000
This function by and first of all requires an input for this keyword that can be this, and then it

09:51.000 --> 09:56.400
has the free arguments that will actually be passed into the off middleware function once it gets called.

09:56.520 --> 09:58.700
So we're not calling it ourselves here.

09:58.710 --> 10:03.330
We're instead passing a prepared reference to our function.

10:03.330 --> 10:08.100
You could say prepared in the sense of we're defining which functions get passed in or which arguments

10:08.100 --> 10:08.930
get passed in.

10:08.940 --> 10:12.780
So we're passing that prepared reference to expect.

10:13.110 --> 10:17.970
And now if you rerun NPM test, you should actually see a passing test.

10:18.240 --> 10:24.660
Now, if you're expecting a slightly different error message and you rerun NPM test, you actually get

10:24.660 --> 10:30.160
a failure because we expect it to throw an error, including not authenticated.

10:30.180 --> 10:30.600
Right.

10:30.600 --> 10:33.720
That is what we're expecting here with an exclamation mark.

10:33.720 --> 10:36.900
But we got no authenticated with a dot.

10:36.900 --> 10:38.580
And that's the idea behind testing.

10:38.580 --> 10:43.380
You have to be clear here, because you can test for all kinds of different things.

10:43.380 --> 10:47.280
And here we're testing for the correct error message being thrown.

10:47.280 --> 10:51.740
And therefore this test only succeeds if we a have an error.

10:51.750 --> 10:57.720
If we are not throwing an error in here, if we're indeed if we're instead sending our own error response

10:57.720 --> 11:01.310
and we're not following an error, then this test would not succeed.

11:01.320 --> 11:06.960
Or if we throw an error with a different error message, as you just saw, this all doesn't exceed.

11:07.710 --> 11:13.440
Now, the cool thing is, if we now ever change something about this code, for example, we decide

11:13.440 --> 11:19.650
to remove this check here where we check for the off header and I now run my test again.

11:21.300 --> 11:27.420
I get an error and that tells me, Oh, I need to do something because my test failed.

11:27.420 --> 11:32.880
This test where I want to make sure that not being able to retrieve the head or actually frozen error,

11:32.880 --> 11:34.500
that does not pass anymore.

11:34.500 --> 11:39.150
And therefore now I should have a look at my middleware and I can find out, Oh, I commented this out

11:39.150 --> 11:44.880
or maybe I never added this functionality in the first place, or I tweaked it in some way that this

11:44.880 --> 11:46.320
error is not thrown anymore.

11:46.350 --> 11:50.130
Maybe I should just check and change this condition accidentally.

11:50.130 --> 11:55.350
I'm checking for the existence of a header to throw that error because I have a typo or because I needed

11:55.350 --> 11:56.970
that in the past or whatever.

11:56.970 --> 12:02.760
Then my test fails as you can see, and I can look into my code and find out why it failed.

12:02.760 --> 12:03.780
And here I see.

12:03.780 --> 12:08.250
I expected it to throw an error, but actually I got a different error.

12:08.250 --> 12:14.070
And since I got a different era, well, it's probably something wrong with this code here.

12:14.070 --> 12:18.750
And I can look into that code and eventually find out that here I'm missing an exclamation mark, for

12:18.750 --> 12:19.440
example.

12:19.440 --> 12:21.540
So that's the idea behind testing.

12:21.540 --> 12:26.610
Whenever we then change something in our code, as long as we have tests for it, we get a warning,

12:26.610 --> 12:30.870
we get a chance of tweaking our code and fixing the issue we introduced.
