WEBVTT

00:02.090 --> 00:08.750
Before we actually move on to the controllers let's now test something more complex here in our is off

00:08.750 --> 00:09.380
middleware.

00:09.680 --> 00:14.880
Thus far we tested whether we have a valid header and that we get an error if we don't.

00:14.900 --> 00:19.370
So if we have no header at all or if it's not applicable, that is all nice.

00:19.370 --> 00:23.150
But what about our actual token verification now?

00:23.180 --> 00:25.580
How could we test this?

00:25.580 --> 00:30.080
How can we make sure that this fails for incorrect tokens?

00:31.090 --> 00:34.510
Well, there are a couple of important things to consider.

00:34.540 --> 00:37.960
First of all, now this is really something you have to memorize.

00:38.260 --> 00:43.200
You should not test whether the verify function works correctly.

00:43.210 --> 00:48.520
You should not test whether this really verifies a token correctly.

00:48.520 --> 00:55.460
So whether it is really fails for incorrect tokens that were not created with that secret.

00:55.480 --> 00:57.610
Why should you not test for that?

00:57.850 --> 01:02.260
Because this is not a function or a method owned by you.

01:02.290 --> 01:08.350
This is coming from a third party package, from the JSON web token package, and it's the job of the

01:08.350 --> 01:12.920
package offers to test their own code and to make sure it works correctly.

01:12.940 --> 01:16.990
So you don't want to test external dependencies.

01:16.990 --> 01:21.220
You don't want to test if verify works correctly or if it has bugs.

01:21.250 --> 01:22.900
Of course it could have.

01:22.900 --> 01:27.120
But it's not your job to test this as part of your application.

01:27.130 --> 01:32.530
If you want to get involved with the development of this package, you can absolutely do so in that

01:32.530 --> 01:34.930
package, but not in your application.

01:35.080 --> 01:38.780
So therefore, we're not testing whether Verify works correctly.

01:38.800 --> 01:45.760
We only want to test if our code behaves correctly when verification fails, for example, or when it

01:45.760 --> 01:46.390
succeeds.

01:46.390 --> 01:52.330
So when we don't get back an object that has a user ID, for example, which we actually do get back,

01:52.330 --> 01:52.750
right.

01:52.750 --> 01:55.390
We get back decoded token with the user ID.

01:55.420 --> 01:58.120
Well, we only get this if this does not fail.

01:58.630 --> 02:05.890
So we don't want to test if verification works correctly, we want to test if our code then behaves

02:05.890 --> 02:09.250
correctly, depending on what verify does.

02:09.730 --> 02:12.520
This introduces one new problem, though.

02:12.790 --> 02:17.440
Verify, of course, comes from a third party package and therefore it does its job.

02:17.620 --> 02:22.840
And now if we want to test, if our code works correctly, it's easy to test for a failure.

02:22.840 --> 02:28.600
We can easily pass on a token that's not verified by this package because we don't actually know which

02:28.600 --> 02:29.810
tokens it creates for us.

02:29.830 --> 02:33.010
You might remember tokens are these super long strings.

02:33.010 --> 02:34.480
We can't guess them.

02:34.480 --> 02:39.880
So whatever we pass into our function here, we'll probably fail here in the verification step.

02:39.880 --> 02:42.490
And indeed, let's actually start with such a test.

02:42.730 --> 02:47.470
It should throw an error if the token.

02:48.240 --> 02:50.400
Cannot be verified.

02:50.730 --> 02:54.240
Let's add our function definition here.

02:55.170 --> 03:00.570
And now again, let's create a dummy request object for this test.

03:00.600 --> 03:02.370
Here I have barer.

03:02.370 --> 03:06.660
And then x, y, z and x, y, z is the token that will actually be used.

03:06.660 --> 03:14.340
And it certainly will be an incorrect token, certainly not a token created by the JWT package.

03:14.850 --> 03:19.260
And therefore now if I expect my middleware.

03:20.370 --> 03:26.810
With my request object, empty response object and this empty next function.

03:26.820 --> 03:32.640
If I expect this to flow, then this test should absolutely succeed.

03:32.640 --> 03:35.490
It should pass because this will throw an error.

03:35.490 --> 03:36.660
And indeed it does.

03:37.140 --> 03:39.840
Of course, if we wanted to test the opposite.

03:39.840 --> 03:41.850
So if we add yet another test.

03:43.270 --> 03:46.660
Where we want to check.

03:46.660 --> 03:52.810
Well, if this is a valid token, then decode it token.

03:53.020 --> 03:56.290
So this object that returns us should have a user ID.

03:56.530 --> 03:59.710
Well, if we test this, it should.

04:01.130 --> 04:06.440
Yield a user ID after decoding the token.

04:07.450 --> 04:13.180
If we want to create such a task and we pass in our token, we hope that this is a valid token, which

04:13.180 --> 04:14.350
it certainly is not.

04:14.800 --> 04:19.090
Well, then we could write our exact function here and now.

04:19.090 --> 04:24.430
We just need to make sure the user ID gets added to the request here.

04:24.430 --> 04:26.680
Write to the request object we pass in.

04:26.680 --> 04:29.680
So now we'll change our code a little bit.

04:29.680 --> 04:31.810
We'll call off middleware manually here.

04:31.810 --> 04:36.490
Now passing a request empty response object empty next function.

04:36.490 --> 04:40.750
But we call it like this request now is our dummy request.

04:40.750 --> 04:47.560
And we now, after we executed this middleware, we now expect our request object to have a new property

04:47.560 --> 04:56.470
because we add a new property in the middleware user ID property and we expect request user ID to be

04:56.470 --> 05:00.220
equal to a certain value or we expect request to.

05:00.220 --> 05:07.210
And that's also something you can test for to have a property which is named user ID, right?

05:07.210 --> 05:12.370
That is something we could expect for a valid token because if the token is valid, if it is verified,

05:12.370 --> 05:19.690
then we make it past destroy catch block, then it just checks again if it really is defined and yes,

05:19.690 --> 05:26.140
we expect it to be defined and then we do get the user ID from the decoded token and we store it in

05:26.140 --> 05:26.890
the request.

05:26.890 --> 05:33.400
So expecting that user ID property to to exist on the request seems valid.

05:33.730 --> 05:40.330
But of course, as you might already guess, if we now run our tests, we'll have a failing test.

05:40.330 --> 05:42.520
And that will of course be our last test.

05:42.880 --> 05:44.080
It should yield.

05:46.210 --> 05:48.460
The user added after decoding the token.

05:48.460 --> 05:52.090
But actually what we do get here is simply an error.

05:52.300 --> 05:57.240
We get that error because our token is malformed because it's too short.

05:57.250 --> 06:05.440
It's basically not fulfilling the criteria of the JWT Verify method and therefore it's throwing an error.

06:05.440 --> 06:07.990
It's throwing an error that the token is malformed.

06:08.920 --> 06:10.630
What can we do in such cases?

06:10.630 --> 06:12.880
We can't of course always test if it fails.

06:12.880 --> 06:19.000
But we also want to test the success case because maybe we have scenarios in our application where it's

06:19.000 --> 06:24.220
not failing with an error and still the user ID is not getting stored in the request because we simply

06:24.220 --> 06:25.510
don't have that code here.

06:25.540 --> 06:32.020
Then we would have a bug in our application which we want to detect with tests and this would not throw

06:32.020 --> 06:33.700
an error at any point here.

06:33.700 --> 06:39.520
It would later in the controller when we try to get that user ID, but it would not throw an error here.

06:39.520 --> 06:43.270
And still we want to detect this error here already.

06:43.270 --> 06:48.940
And therefore a test like this one would be super important because here we test whether we have a user

06:48.940 --> 06:52.690
ID stored in the request object after running the middleware.

06:53.050 --> 07:01.150
So to find that we need some way of shutting down that verify method though we know that this is not

07:01.150 --> 07:04.240
a valid token, but for this test we don't care.

07:04.240 --> 07:08.890
We want to test a scenario where we do have a valid token, right?

07:08.890 --> 07:11.710
We don't want to test whether verification works correctly.

07:11.710 --> 07:17.080
We know that this normally would not be a valid token, but this is not important to us here.

07:17.080 --> 07:18.940
We don't care about whether this is valid.

07:18.940 --> 07:21.550
We know that verification will work in the actual app.

07:21.550 --> 07:27.010
We don't need to test whether it is really fails for a random token here.

07:27.010 --> 07:32.230
We want it to succeed for a random token because we then want to test something totally different.

07:32.230 --> 07:37.720
We want to test if our app works correctly for valid tokens, no matter if this really is a valid token

07:37.720 --> 07:38.740
here or not.

07:38.830 --> 07:44.680
I hope this is clear because it is an important part of testing that you think about testing this way

07:44.680 --> 07:50.380
that you are fine defining your own scenarios and overwriting certain functionalities to test something

07:50.380 --> 07:50.890
else.

07:51.160 --> 07:57.700
So how can we now shut down, verify and make sure it simply gives us an object with a user ID so that

07:57.700 --> 08:00.280
we can pull that user ID from that object.
