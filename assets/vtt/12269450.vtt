WEBVTT

00:02.320 --> 00:06.470
Now that we briefly walked through npm and what we use it for,

00:06.640 --> 00:09.630
let's bring something back into our memory. Nodejs

00:09.640 --> 00:16.090
in this course was primarily used to spin up a web server and write code that runs on the server

00:16.090 --> 00:23.280
side and that is indeed the main thing you do with nodejs when you write your own nodejs apps.

00:23.410 --> 00:29.320
But we have to remember that theoretically you can run any javascript code with nodejs and specifically

00:29.320 --> 00:32.360
you can also interact with your local file system,

00:32.380 --> 00:34.580
you can read and write files after all

00:34.870 --> 00:39.220
and that opens us a new door, a new opportunity.

00:39.220 --> 00:46.900
We could use nodejs to execute utility scripts that for example parse certain files, manipulate

00:46.900 --> 00:53.460
the content and output the manipulated content back into the original file or into a new file

00:53.560 --> 00:59.800
and that is the idea behind so-called build tools and that is something nodejs also is capable of

00:59.800 --> 01:01.090
being used for.

01:01.660 --> 01:08.680
And it's important pointing out here that when we talk about build tooling and build workflows, we mostly

01:08.680 --> 01:16.900
talk about frontend web development, like for example with our react application here. This react application

01:16.900 --> 01:24.430
is not a nodejs app but still we use a package.json file and we use npm to install packages.

01:24.430 --> 01:31.240
These packages are all holding code that runs in the browser though and in the end, the code we write

01:31.240 --> 01:34.400
here in the source folder will also end up in the browser

01:34.420 --> 01:40.780
but let me point out that the way we write it here would not run in browsers, at least not in all browsers.

01:41.020 --> 01:47.920
For example we are splitting our javascript code here across multiple files and we're using es module

01:48.070 --> 01:51.760
import syntax for merging these files together.

01:51.760 --> 01:58.990
Now this does not natively work in all browsers, only in very modern browsers and therefore this is

01:58.990 --> 02:02.140
indeed not the code that will end up in the browser.

02:02.140 --> 02:03.810
This is the code we work with

02:03.880 --> 02:11.440
but we use a build tool, a build workflow which is started during development with npm start and for production

02:11.440 --> 02:18.280
with npm run build, this build workflow will take our code and kind of merge it together and transform

02:18.280 --> 02:21.770
it into code that runs in older browsers too

02:21.940 --> 02:30.130
and that is also minified and optimized because that's also important. We use build tools to optimize

02:30.130 --> 02:30.970
our code,

02:31.000 --> 02:33.230
we might write code that looks like this and

02:33.250 --> 02:35.920
that is indeed how our code looks like in the react

02:36.010 --> 02:37.000
I just showed you.

02:37.300 --> 02:40.330
But as I mentioned, this does not run in all browsers

02:40.330 --> 02:43.910
and even if it would, it would be very large in the browser

02:43.930 --> 02:47.560
since all the code has to be downloaded by your users before it runs

02:47.680 --> 02:52.140
and that's different on the server, there the code sits on the server and that's it, in the browser

02:52.150 --> 02:57.730
the code has to be downloaded and therefore you want to keep it as small as possible so that your app

02:57.760 --> 03:01.810
and your javascript code in the browser starts as quickly as possible.

03:02.080 --> 03:07.630
Therefore we want to end up with optimized code and the idea here is that we also have code that is

03:07.630 --> 03:14.550
not only too big but that is using next gen features, like here the spread operator or arrow functions and

03:14.550 --> 03:18.370
we want to convert this to code that runs an older browsers too

03:18.370 --> 03:24.310
and that is like an example optimized code which is shorter, we use less characters and therefore the

03:24.310 --> 03:29.280
code is shorter and it also does not use next generation javascript features.

03:29.480 --> 03:35.140
And that is the idea and as I mentioned, it's primarily important for frontend development because there,

03:35.230 --> 03:37.960
not all browsers support the next features

03:37.960 --> 03:41.770
and we want to keep our code as small as possible,

03:41.830 --> 03:45.680
that does not really matter that much on the server side.

03:45.700 --> 03:47.050
So that is the idea and

03:47.080 --> 03:49.650
that is what we can use node and npm for

03:49.780 --> 03:55.560
because if we go back to our react project, we want to convert that code into optimized version

03:55.890 --> 04:02.770
and if you run npm run build in your project here, you actually start such a production workflow which

04:02.770 --> 04:06.050
means now it's creating an optimized production bundle

04:06.250 --> 04:12.360
and this is all done by npm which started the script and by node.

04:12.760 --> 04:19.000
And here it completed and now indeed if we look into this build folder, this now holds our app code,

04:19.030 --> 04:20.740
so the code we wrote in source

04:20.800 --> 04:27.670
but in an optimized way. There in the static folder, we have javascript code and if we look into that,

04:28.070 --> 04:30.030
this in the end is our code,

04:30.070 --> 04:36.540
just minified a lot and therefore it's pretty hard to read but it's our code and this code is not

04:36.540 --> 04:43.330
just very condensed and only contains current gen javascript logic, so logic that runs in older browsers

04:43.330 --> 04:46.570
too. This is of course not the code we would like to write,

04:46.570 --> 04:53.050
it's very hard to dig through that but it is the code we want to output and we use npm and node to transform

04:53.050 --> 04:53.640
our code.

04:53.650 --> 04:55.650
That's the idea behind build tooling

04:55.900 --> 04:59.740
and now let's have a closer look at how npm and node can help us with that.
