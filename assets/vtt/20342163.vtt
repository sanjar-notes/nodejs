WEBVTT

1
00:00:02.110 --> 00:00:04.720
<v ->I want to start with some extra TypeScript features,</v>

2
00:00:04.720 --> 00:00:06.480
which you can utilize.

3
00:00:06.480 --> 00:00:08.779
Maybe you saw that when I accessed

4
00:00:08.779 --> 00:00:12.560
the request body or the request params,

5
00:00:12.560 --> 00:00:14.710
I get auto-completion as long as I

6
00:00:14.710 --> 00:00:16.510
work on the request object.

7
00:00:16.510 --> 00:00:18.450
For example, there I get help

8
00:00:18.450 --> 00:00:22.000
and I can understand that there is a body property.

9
00:00:22.000 --> 00:00:24.380
But what I then access on the body itself

10
00:00:24.380 --> 00:00:26.130
is really flexible.

11
00:00:26.130 --> 00:00:27.800
I can access anything there

12
00:00:27.800 --> 00:00:30.050
because the TypeScript does not understand

13
00:00:30.050 --> 00:00:32.800
what will be in the body of the incoming request.

14
00:00:32.800 --> 00:00:34.750
And the same for the params.

15
00:00:34.750 --> 00:00:36.490
You could argue that it should be able

16
00:00:36.490 --> 00:00:38.830
to understand what's in it because

17
00:00:38.830 --> 00:00:40.540
we encode it here,

18
00:00:40.540 --> 00:00:42.530
but that's not how TypeScript works.

19
00:00:42.530 --> 00:00:45.480
It's not able to analyze your averacode

20
00:00:45.480 --> 00:00:48.253
to understand what should be in this params object.

21
00:00:49.500 --> 00:00:50.970
Long story short,

22
00:00:50.970 --> 00:00:53.790
params as well as body,

23
00:00:53.790 --> 00:00:54.970
in the end here,

24
00:00:54.970 --> 00:00:57.320
is of type any.

25
00:00:57.320 --> 00:00:59.180
That's the type of body and

26
00:00:59.180 --> 00:01:00.890
that's the type of params.

27
00:01:00.890 --> 00:01:03.510
Well, params is actually a params dictionary.

28
00:01:03.510 --> 00:01:05.300
But that's essentially just an object

29
00:01:05.300 --> 00:01:06.580
with key value pairs,

30
00:01:06.580 --> 00:01:08.683
where any keys are allowed.

31
00:01:09.740 --> 00:01:11.800
The problem with that simply is that

32
00:01:11.800 --> 00:01:13.620
we don't get the best possible

33
00:01:13.620 --> 00:01:15.220
TypeScript support here.

34
00:01:15.220 --> 00:01:17.330
If I wrote texts here,

35
00:01:17.330 --> 00:01:20.200
nobody would warn me about this mistake.

36
00:01:20.200 --> 00:01:21.550
And we're using TypeScript

37
00:01:21.550 --> 00:01:23.990
to avoid mistakes like this.

38
00:01:23.990 --> 00:01:26.200
Of course TypeScript can't anticipate

39
00:01:26.200 --> 00:01:27.450
which kind of data we get

40
00:01:27.450 --> 00:01:29.450
on incoming requests,

41
00:01:29.450 --> 00:01:31.330
but we as a developer should know

42
00:01:31.330 --> 00:01:33.170
which kind of data we get there.

43
00:01:33.170 --> 00:01:35.760
We can let TypeScript know about this.

44
00:01:35.760 --> 00:01:38.520
And now to make TypeScript aware of our knowledge

45
00:01:38.520 --> 00:01:40.740
of how a request body should look like,

46
00:01:40.740 --> 00:01:42.890
we can alter this a little bit.

47
00:01:42.890 --> 00:01:45.113
We can set the body here,

48
00:01:46.760 --> 00:01:48.980
equal to request body,

49
00:01:48.980 --> 00:01:51.790
and then use type conversion

50
00:01:51.790 --> 00:01:53.370
with the ask keyword

51
00:01:53.370 --> 00:01:57.230
to convince TypeScript that this is of a certain type.

52
00:01:57.230 --> 00:02:00.060
And now we can define a type of our choice

53
00:02:00.060 --> 00:02:02.170
that reflects how a body,

54
00:02:02.170 --> 00:02:04.310
how a request body for this route,

55
00:02:04.310 --> 00:02:05.340
should look like.

56
00:02:05.340 --> 00:02:06.300
So for example, here,

57
00:02:06.300 --> 00:02:08.090
we set this to an object type,

58
00:02:08.090 --> 00:02:10.360
where we know that there will be a text property

59
00:02:10.360 --> 00:02:12.220
which would be a string.

60
00:02:12.220 --> 00:02:15.233
And now if we use this new body down there,

61
00:02:16.130 --> 00:02:17.810
we can access text on that,

62
00:02:17.810 --> 00:02:21.400
but if it access texts, I get an error.

63
00:02:21.400 --> 00:02:23.270
Of course we can generalize this.

64
00:02:23.270 --> 00:02:24.890
I can extract this type and

65
00:02:24.890 --> 00:02:27.143
create a new type alias up there.

66
00:02:28.390 --> 00:02:32.583
Request body, set this equal to this object type,

67
00:02:33.610 --> 00:02:35.870
and then use this request body type alias

68
00:02:35.870 --> 00:02:38.130
for my conversion down there,

69
00:02:38.130 --> 00:02:42.070
and also in any other places where I expect something.

70
00:02:42.070 --> 00:02:44.950
For example, here,

71
00:02:44.950 --> 00:02:47.253
where I expect to get data,

72
00:02:50.130 --> 00:02:51.790
like this.

73
00:02:51.790 --> 00:02:54.410
I can utilize this body in all the places

74
00:02:54.410 --> 00:02:56.180
where I access request body

75
00:02:56.180 --> 00:02:58.130
to get that extra type safety,

76
00:02:58.130 --> 00:03:00.080
and avoid typos.

77
00:03:00.080 --> 00:03:02.800
And of course we can do the same with the params.

78
00:03:02.800 --> 00:03:05.170
We know how the params will look like,

79
00:03:05.170 --> 00:03:09.150
so I could add a type alias here, request params,

80
00:03:09.150 --> 00:03:11.310
but with that we could register

81
00:03:11.310 --> 00:03:15.600
another object type here on this type alias,

82
00:03:15.600 --> 00:03:18.880
and add the todo ID, which is also a string.

83
00:03:18.880 --> 00:03:21.300
And then we can use the exact same pattern

84
00:03:21.300 --> 00:03:22.633
on the params.

85
00:03:24.610 --> 00:03:27.390
So here I got my params,

86
00:03:27.390 --> 00:03:31.440
which is request params as RequestParams,

87
00:03:31.440 --> 00:03:33.660
and now I can use params here,

88
00:03:33.660 --> 00:03:36.450
and again if I now have a lower case I,

89
00:03:36.450 --> 00:03:39.620
for example, I get a warning via TypeScript.

90
00:03:39.620 --> 00:03:42.900
So now we have this improved TypeScript usage here.

91
00:03:42.900 --> 00:03:46.313
And of course we can do the same here for deletion.

92
00:03:48.900 --> 00:03:51.700
Now, of course you can define multiple aliases

93
00:03:51.700 --> 00:03:53.100
for bodies and params

94
00:03:53.100 --> 00:03:54.410
if you have different routes

95
00:03:54.410 --> 00:03:56.580
with different kinds of bodies and params.

96
00:03:56.580 --> 00:03:58.700
Here, I just always happen to work

97
00:03:58.700 --> 00:04:00.960
with the same kind of request body

98
00:04:00.960 --> 00:04:02.940
and the same kind of request params,

99
00:04:02.940 --> 00:04:04.430
but you could have multiple,

100
00:04:04.430 --> 00:04:07.260
differently named type aliases here,

101
00:04:07.260 --> 00:04:09.589
to use this pattern in different routes.

102
00:04:09.589 --> 00:04:12.460
With that, we improve this code even more.

103
00:04:12.460 --> 00:04:16.060
And now, we're really taking advantage of TypeScript

104
00:04:16.060 --> 00:04:18.170
to force us, as a developer,

105
00:04:18.170 --> 00:04:19.673
to write better code.

