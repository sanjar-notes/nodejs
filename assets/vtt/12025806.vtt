WEBVTT

00:02.270 --> 00:08.710
Now that we learned about this express error handling middleware which we can use, which we added,

00:08.990 --> 00:15.350
what exactly does throw new error in this catch block, in this middleware in the app.js file do for us?

00:15.350 --> 00:18.600
I mentioned that this will become important. Now

00:18.680 --> 00:22.100
like this, it'll unfortunately not do anything.

00:22.100 --> 00:29.150
Let me start up our server real quick again and let me ensure that we do get an error by simply throwing

00:29.270 --> 00:30.890
a new error, a dummy error

00:30.890 --> 00:34.430
here, again to simply simulate that something goes wrong.

00:34.430 --> 00:35.350
I throw it here,

00:35.420 --> 00:39.710
if I throw it in a then block, the next catch block will catch it and handle it,

00:39.710 --> 00:41.410
now let's see what this does.

00:41.570 --> 00:50.210
Now to see the effect, I have to log in to ensure that we do get a user session and we can already see

00:50.330 --> 00:51.660
this crashes here,

00:51.680 --> 00:56.460
it loads infinitely because I have an error here,

00:56.940 --> 00:58.730
my dummy error.

00:59.020 --> 01:02.000
So this is now not doing anything,

01:02.100 --> 01:04.220
the app is still crashing.

01:04.350 --> 01:10.980
So one important takeaway is throwing an error here does not lead to our general error handling middleware

01:10.980 --> 01:13.730
being called and that is important.

01:13.740 --> 01:18.140
This is true because we're inside some async code, we're inside a promise here,

01:18.170 --> 01:24.360
we're inside a then or a catch block. If you throw errors there, you will not reach that

01:24.360 --> 01:26.570
express error handling middleware.

01:26.580 --> 01:32.230
The interesting thing is if you would throw an error outside of async code,

01:32.330 --> 01:34.940
so in a place where the code executes synchronously,

01:35.100 --> 01:40.800
so basically outside of a promise, then catch block or outside of a callback,

01:40.800 --> 01:46.730
so here if I throw my sync dummy like this, if we do that,

01:46.770 --> 01:49.140
so this is now throwing in a normal function,

01:49.200 --> 01:52.630
not nested inside a promise or a callback or anything like that.

01:52.860 --> 01:59.470
If I now reload this, you'll see that it tried to load the 500 page but it still failed.

01:59.490 --> 02:01.310
The reason for this is really simple,

02:01.350 --> 02:07.720
we have our middleware in place here where I retrieve my user and there I throw the error

02:07.740 --> 02:10.400
but this executes for every incoming request.

02:10.440 --> 02:16.180
Now when we redirect here, we do send a new request so we kind of enter an infinite loop here,

02:16.320 --> 02:17.600
we execute this again,

02:17.670 --> 02:18.670
it throws an error,

02:18.780 --> 02:25.860
we go to the error handling middleware, we trigger a new request. A solution here can be to simply

02:25.860 --> 02:32.600
not redirect to 500 but immediately execute our rendering code,

02:32.670 --> 02:38.760
so this code in our get 500 controller action and we could absolutely do that.

02:38.790 --> 02:48.630
We could render our error here instead of redirecting, we could render our page here and if we do that,

02:48.930 --> 02:50.660
you will see that now if I reload,

02:51.120 --> 02:58.350
I just get a problem regarding my csrf token because that can't be generated based on the incoming request

02:58.380 --> 03:06.160
because the request basically has issues here in our middleware before we set up the csrf token.

03:06.300 --> 03:12.960
So the solution for that would be to switch the order to make sure we set this token before we actually

03:12.990 --> 03:16.940
do something with the user which we tried to fetch,

03:16.950 --> 03:20.730
so now this works and now we get an error handling in place.

03:20.730 --> 03:26.280
The interesting thing is not just that we had to switch the order though and that we should avoid infinite

03:26.280 --> 03:26.980
loops

03:27.150 --> 03:31.150
but the interesting thing here also is that here I'm just throwing an error

03:31.260 --> 03:34.270
and we still reach this global error handling middleware.

03:34.380 --> 03:40.830
The reason for that is that in synchronous places, so outside of callbacks and promises, you throw an error

03:40.950 --> 03:47.810
and express will detect this and execute your next error handling middleware. Inside of async code,

03:47.850 --> 03:48.890
so inside of

03:48.900 --> 03:51.280
then, catch or callbacks,

03:51.300 --> 03:52.870
this does not work however.

03:53.120 --> 03:58.590
Inside of that, you have to use next with an error included.

03:58.680 --> 04:04.320
So this is then detected by express again and this is what we used in the other files and inside of async

04:04.320 --> 04:05.640
code snippets, you need to use

04:05.640 --> 04:08.390
next wrapping that error, outside

04:08.400 --> 04:10.410
you can just throw that error.

04:10.730 --> 04:19.380
And so if I now uncomment this, you will see that if I try to reload my page, I get this error no matter what

04:19.380 --> 04:25.150
I do because I still have this dummy error being thrown in my promise, hence the catch block executes, hence 

04:25.160 --> 04:26.690
this line executes.

04:26.730 --> 04:32.280
So now I will get rid of that but I will leave this catch block as it is and you have to understand

04:32.460 --> 04:38.530
that for one, you should avoid infinite loops triggered through your error handling middleware as we had it

04:38.550 --> 04:39.440
initially here

04:39.720 --> 04:46.710
and second, that you can throw the error in synchronous code places like this one but inside of promise, then

04:46.730 --> 04:50.490
or catch blocks or inside of callbacks, you have to use

04:50.490 --> 04:52.340
next around the error.
