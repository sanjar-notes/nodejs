WEBVTT

1
00:00:02.190 --> 00:00:03.630
<v Instructor>Now, last, but not least,</v>

2
00:00:03.630 --> 00:00:07.980
to sum up this basics refresher, let's talk about generics.

3
00:00:07.980 --> 00:00:11.160
Generics are a feature that can look very confusing

4
00:00:11.160 --> 00:00:14.030
at first, but it makes a lot of sense.

5
00:00:14.030 --> 00:00:17.900
Actually, in our code here, we already have a generic type,

6
00:00:17.900 --> 00:00:20.090
our two array types here.

7
00:00:20.090 --> 00:00:22.290
A generic type simply is a type

8
00:00:22.290 --> 00:00:24.830
that interacts with another type,

9
00:00:24.830 --> 00:00:27.930
and an array is a great example.

10
00:00:27.930 --> 00:00:29.800
An array is a type on its own.

11
00:00:29.800 --> 00:00:32.880
It's a list of data, that's the core type,

12
00:00:32.880 --> 00:00:35.150
but it interacts with another type,

13
00:00:35.150 --> 00:00:37.860
the type of data inside of the array.

14
00:00:37.860 --> 00:00:41.030
So, you could say that the array is the outer type,

15
00:00:41.030 --> 00:00:43.500
but then you have all the elements in the array

16
00:00:43.500 --> 00:00:45.400
as an inner type.

17
00:00:45.400 --> 00:00:48.700
And this here, this way of defining an array type,

18
00:00:48.700 --> 00:00:51.460
is actually just a shortcut in TypeScript.

19
00:00:51.460 --> 00:00:53.330
The longer form would be

20
00:00:53.330 --> 00:00:56.770
that we set numResults to type Array,

21
00:00:56.770 --> 00:00:59.460
but now array is a so-called generic type,

22
00:00:59.460 --> 00:01:03.850
and you have to define the wrapped, the inner type,

23
00:01:03.850 --> 00:01:07.390
in this case, the value types of the values

24
00:01:07.390 --> 00:01:09.490
inside of the array, and you do so

25
00:01:09.490 --> 00:01:11.480
by adding angle brackets here,

26
00:01:11.480 --> 00:01:14.090
the smaller than and the greater than sign,

27
00:01:14.090 --> 00:01:17.230
and, between that, the generic type of array.

28
00:01:17.230 --> 00:01:19.440
So, in this case, number.

29
00:01:19.440 --> 00:01:23.570
And this says that numResults is an array full of numbers.

30
00:01:23.570 --> 00:01:27.530
Now, what the thing between angle brackets refers to

31
00:01:27.530 --> 00:01:30.580
depends on the generic type you are working with.

32
00:01:30.580 --> 00:01:34.330
Another example for a generic type would be a promise.

33
00:01:34.330 --> 00:01:37.551
Now, for that, we can create a new promise down there,

34
00:01:37.551 --> 00:01:40.290
myPromise, by calling new Promise.

35
00:01:40.290 --> 00:01:42.590
And, by default, this code won't work here

36
00:01:42.590 --> 00:01:46.230
because we need to add a library to tsconfig

37
00:01:46.230 --> 00:01:49.950
to, basically, tell tsconfig which kind of features

38
00:01:49.950 --> 00:01:51.560
we wanna support.

39
00:01:51.560 --> 00:01:54.790
And, for example, by default here, because of this target,

40
00:01:54.790 --> 00:01:57.580
it's configured to compile the TypeScript code down

41
00:01:57.580 --> 00:02:01.000
to es5 JavaScript code, which is quite old.

42
00:02:01.000 --> 00:02:05.820
If we pick es6 here, for example,

43
00:02:07.700 --> 00:02:09.010
now this will work.

44
00:02:09.010 --> 00:02:11.630
We still get an error, but now it's a different error.

45
00:02:11.630 --> 00:02:14.600
So, we just have to ensure that we're telling TypeScript

46
00:02:14.600 --> 00:02:16.860
that we're working with a JavaScript version

47
00:02:16.860 --> 00:02:18.440
that supports promise.

48
00:02:18.440 --> 00:02:21.150
Because promise, of course, is not a TypeScript feature,

49
00:02:21.150 --> 00:02:23.190
it can't be compiled to something

50
00:02:23.190 --> 00:02:24.920
that works in older JavaScript.

51
00:02:24.920 --> 00:02:26.880
Instead, we need to tell TypeScript

52
00:02:26.880 --> 00:02:28.800
that we wanna compile to JavaScript,

53
00:02:28.800 --> 00:02:30.430
which natively supports promise.

54
00:02:30.430 --> 00:02:34.670
And that's what we just did by changing the target to es6.

55
00:02:34.670 --> 00:02:37.680
With that, we can define our promise here.

56
00:02:37.680 --> 00:02:42.293
And a promise gets an argument which is a function,

57
00:02:43.530 --> 00:02:45.990
and that function itself gets two arguments,

58
00:02:45.990 --> 00:02:48.350
a resolve and a reject function,

59
00:02:48.350 --> 00:02:51.810
and, inside of the promise when we define it on our own,

60
00:02:51.810 --> 00:02:55.860
we can, for example, set a timeout to execute some code

61
00:02:55.860 --> 00:02:59.640
after a second, and after that second we resolve the promise

62
00:02:59.640 --> 00:03:01.593
with, It worked!

63
00:03:02.810 --> 00:03:05.240
And then, we can use our own promise here

64
00:03:06.670 --> 00:03:11.670
to listen to the result, and console.log it here.

65
00:03:12.050 --> 00:03:15.260
And we could also add catch to react to the rejection

66
00:03:15.260 --> 00:03:16.320
of the promise.

67
00:03:16.320 --> 00:03:18.290
And now, let's compile this.

68
00:03:18.290 --> 00:03:20.270
By the way, now with a config file,

69
00:03:20.270 --> 00:03:22.900
don't select the file manually

70
00:03:22.900 --> 00:03:25.330
otherwise the config file won't be taken into account

71
00:03:25.330 --> 00:03:26.240
by the compiler.

72
00:03:26.240 --> 00:03:28.090
It is taken into account by the IDE,

73
00:03:28.090 --> 00:03:29.770
but not by the compiler.

74
00:03:29.770 --> 00:03:33.610
Instead, just press tsc like this, enter tsc like this,

75
00:03:33.610 --> 00:03:36.500
and it will compile all TypeScript files in the folder.

76
00:03:36.500 --> 00:03:39.010
And now, it compiled this code.

77
00:03:39.010 --> 00:03:43.860
And if we now reload, you see, It worked, after one second.

78
00:03:43.860 --> 00:03:46.730
But now, why is the promise a generic type?

79
00:03:46.730 --> 00:03:49.420
Because it eventually resolves to a value,

80
00:03:49.420 --> 00:03:51.630
and the value it resolves to,

81
00:03:51.630 --> 00:03:54.170
that's the generic type for the promise.

82
00:03:54.170 --> 00:03:57.240
For the array, it was the value stored in the array.

83
00:03:57.240 --> 00:04:00.380
For the promise, it's the value the promise resolves to.

84
00:04:00.380 --> 00:04:02.930
And, for example, here it resolves to a string,

85
00:04:02.930 --> 00:04:06.700
and, hence, we should be able to call split here,

86
00:04:06.700 --> 00:04:11.700
for example, and split on the w.

87
00:04:11.850 --> 00:04:12.990
But this does not work

88
00:04:12.990 --> 00:04:15.060
because TypeScript does not understand

89
00:04:15.060 --> 00:04:16.520
that this is a string.

90
00:04:16.520 --> 00:04:18.960
It does not know the type.

91
00:04:18.960 --> 00:04:22.100
Well, by adding angle brackets after Promise,

92
00:04:22.100 --> 00:04:25.810
we can set the type to which promise will resolve to

93
00:04:25.810 --> 00:04:27.240
to a string.

94
00:04:27.240 --> 00:04:30.890
Now, you can't set angle brackets on every built-in object.

95
00:04:30.890 --> 00:04:33.230
It needs to be an object that supports this,

96
00:04:33.230 --> 00:04:36.540
but the promise object, the promise constructor function,

97
00:04:36.540 --> 00:04:40.510
does support generic types because you can set the value

98
00:04:40.510 --> 00:04:42.800
the promise will eventually resolve to.

99
00:04:42.800 --> 00:04:46.100
And now, you see that split down there works,

100
00:04:46.100 --> 00:04:49.030
and if I recompile this and reload,

101
00:04:49.030 --> 00:04:52.640
we see an array, it orked!, because of split.

102
00:04:52.640 --> 00:04:57.180
So, generic types can be tricky the first time you see them,

103
00:04:57.180 --> 00:04:58.920
but they make a lot of sense,

104
00:04:58.920 --> 00:05:02.040
and they give you extra type safety

105
00:05:02.040 --> 00:05:04.530
when working with more complex types

106
00:05:04.530 --> 00:05:07.483
or types that are simply connected to each other.

