WEBVTT

00:02.410 --> 00:08.730
Now it's finally time to work on that react application we have as a frontend here which you also

00:08.740 --> 00:14.590
find attached to this lecture again in case you skipped the other modules, so react application will not work

00:14.590 --> 00:20.400
on the code here too much because this is no react course and now I'm interested in signing users up.

00:20.410 --> 00:26.140
This is done in the app.js file there and there in the sign up handler. Here we send the request

00:26.140 --> 00:27.960
for creating a new user

00:28.120 --> 00:31.750
but this is of course a request from the rest API world.

00:32.200 --> 00:38.270
You learned that from now on, there only is /graphql for all our API requests

00:38.530 --> 00:42.290
and then here this has to be a post request.

00:42.390 --> 00:50.240
The type is still application json and this needs to be set but the body will now be in the graphql

00:50.240 --> 01:01.060
query language and for this, I'll create a new constant which I'll name graphql query,

01:01.130 --> 01:06.020
the name is up to you though and this will be a javascript object where you need to have a query key,

01:06.410 --> 01:10.180
that is required even for mutations.

01:10.180 --> 01:17.150
The value here then is a string which you create with double back ticks, back ticks so that you can write

01:17.180 --> 01:20.830
multiline string, single quotation marks will not do it

01:21.230 --> 01:29.150
and here you add mutation to define that you're running a mutation now, curly braces and now the

01:29.150 --> 01:30.700
name of the mutation and

01:30.800 --> 01:34.740
the name of the mutation you want to execute is create user.

01:35.210 --> 01:38.650
Essentially you could just copy this query here

01:38.660 --> 01:45.720
now, this is what you could copy and what you could move into your query here.

01:47.450 --> 01:52.950
Now of course we need to replace these values with the values we fetch from the user input though and

01:53.020 --> 01:58.300
we can do that by using dollar sign curly braces in this back

01:58.610 --> 02:04.820
tick enclosed string because this is a template literal and this allows us to inject values.

02:04.820 --> 02:09.810
Now just make sure you keep the double quotation marks around and the injected values

02:09.830 --> 02:16.250
otherwise this will fail because this query language here needs to enclose strings in double quotation

02:16.250 --> 02:17.670
marks.

02:17.690 --> 02:24.920
Now the email can be retrieved just as we retrieve it down there, so we can copy that code up there

02:25.130 --> 02:30.220
and the same of course also for the name and the password, so for the name,

02:30.320 --> 02:36.650
we also inject the value of dollar sign curly braces and we use that syntax from below

02:37.010 --> 02:39.100
and the same for the password.

02:39.140 --> 02:44.430
Let's copy that and replace this with the injected password code.

02:48.020 --> 02:50.890
Now here I am retrieving ID and email,

02:51.020 --> 02:53.110
it's up to you, we don't need any of the data,

02:53.180 --> 02:59.520
I'll leave it like this and now this is the object I want to stringify,

02:59.600 --> 03:02.870
so my graphql query object.

03:02.990 --> 03:07.010
Now I don't need to check the status code here because that will not be set,

03:07.070 --> 03:09.640
it's either 200 or 500,

03:09.670 --> 03:18.430
I'll cut it here and I'll remove that and in the response data then block here, where I have the parsed

03:18.430 --> 03:21.460
request, response body, there

03:21.680 --> 03:31.980
I can now check if response data has errors and there on the first error, I could check for the status

03:31.980 --> 03:33.380
field.

03:33.430 --> 03:38.170
So here I will check if response data has errors, if

03:38.590 --> 03:44.500
that's the case I'll check if response state errors and there the first element has a status field

03:44.740 --> 03:45.730
just as I explained,

03:45.730 --> 03:53.510
accessing this field and if that is equal to 422 and then I can throw my validation failed error.

03:53.650 --> 03:59.530
Maybe we have other kinds of errors so I'll check another of thing here in case we don't throw that first

03:59.530 --> 04:00.050
error,

04:00.190 --> 04:03.020
I'll check just for the existence of errors

04:03.280 --> 04:07.120
and there I would throw another new error where I just throw

04:07.130 --> 04:11.040
user creation failed, like this.

04:12.940 --> 04:17.070
Now after these error checks, I'm printing my response data here

04:17.260 --> 04:20.920
and actually we should have all we need to sign users up now.

04:21.100 --> 04:25.120
So let's run our frontend server with npm start,

04:25.120 --> 04:27.650
it runs on localhost 3000

04:27.670 --> 04:31.810
so let's open that here and there,

04:31.920 --> 04:36.800
let's navigate to the sign up page and create a new user.

04:36.800 --> 04:39.400
Now this is an email address which is already taken

04:39.710 --> 04:43.430
and actually therefore, I should fail doing that.

04:43.430 --> 04:46.080
Let me click sign up and indeed I get an error

04:46.130 --> 04:53.480
but this is a different error than you might expect. It's an error here where my method is not allowed and

04:53.480 --> 04:56.870
this can be a tricky thing to fix if you're brand new to graphql.

04:56.920 --> 05:01.740
Well the reason for this error is we get this error

05:01.760 --> 05:09.750
actually as a response to our options request here, not to our post request.

05:09.790 --> 05:16.060
Now you might remember that I explained that the browser sends an options request before it sends the

05:16.060 --> 05:19.800
post, patch, put, delete or so on request.

05:19.810 --> 05:28.530
The problem is express graphql automatically declines anything which is not a post or get request,

05:28.630 --> 05:31.990
so the options request is denied.

05:31.990 --> 05:39.850
The solution is to go to that middleware where I setup my cors headers and there, I check if my request

05:39.910 --> 05:49.210
method is equal to options and if it is an options request, then here I'll return res send status

05:49.210 --> 05:49.880
200,

05:50.080 --> 05:53.940
so I'll simply send an empty response with a status code of 200.

05:54.160 --> 06:00.990
I return so that this code is not executed and therefore options requests never make it to the graphql

06:01.030 --> 06:04.070
endpoint but still get a valid response.

06:05.110 --> 06:11.620
And with that if I now go back to my frontend, I clear my errors and sign up again,

06:11.620 --> 06:17.890
now the user creation fails but now it simply fails because if you look into our data, we see that the

06:17.890 --> 06:21.230
user exists already and that is what we expected

06:21.600 --> 06:27.530
and now if we take a valid email address which is not taken yet, it actually succeeds

06:27.710 --> 06:34.070
and here is the response I get back from graphql, my data that is provided automatically for the

06:34.070 --> 06:35.500
create user query, the

06:35.690 --> 06:42.830
to data fields I requested. And this is how we connect the frontend to our backend by simply sending

06:42.830 --> 06:46.640
a post request with a valid graphql query expression.
