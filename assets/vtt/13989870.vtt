WEBVTT

00:02.100 --> 00:08.280
Now obviously we can test way more about our controllers, but that is basically now all about stuff

00:08.280 --> 00:10.240
that I already explained to you.

00:10.260 --> 00:12.150
You can write different expectations.

00:12.150 --> 00:15.330
You can set up different request objects.

00:15.330 --> 00:20.340
You pass in with different email addresses and passwords, and that allows you to play around and expect

00:20.340 --> 00:21.330
different things.

00:21.480 --> 00:26.760
But I also mentioned that there is more than one way of dealing with code that accesses a database.

00:26.880 --> 00:31.540
The way we deal with it thus far is that we simply stop it away.

00:31.560 --> 00:37.020
We create a stub for the find one method and then define what this should do for this test case.

00:37.020 --> 00:38.280
And then I restore it.

00:38.280 --> 00:40.530
And that is absolutely fine.

00:40.560 --> 00:44.520
It prevents the real database access from happening here.

00:44.520 --> 00:50.370
And that, of course, might be what we want because it allows us to run our test faster and of course,

00:50.370 --> 00:50.940
important.

00:50.940 --> 00:57.540
It also doesn't impact the database because your tests could still write data to the database and you

00:57.540 --> 01:02.070
definitely don't want this to happen in your production database at least.

01:02.840 --> 01:10.790
It is, however, a valid setup to use a dedicated testing database because whilst of course the downside

01:10.790 --> 01:18.300
is that your test will run a bit longer, the upside is that you have a very realistic testing environment.

01:18.320 --> 01:24.800
If you really hit a database and you really write data to that database and you read it from there,

01:24.800 --> 01:27.350
you have a bit of more.

01:27.380 --> 01:28.730
You don't just have a unit test.

01:28.730 --> 01:34.820
You have kind of a integration test because you have a full flow of controller gets executed, model

01:34.820 --> 01:38.270
does its job, reaches out to the database, returns data.

01:38.360 --> 01:44.960
You have more than just a unit test, but you also have a test under very realistic circumstances.

01:44.960 --> 01:51.440
And in some cases this might be what you want and it might be easier than stopping everything and writing

01:51.440 --> 01:53.090
a lot of stubbing code.

01:53.270 --> 02:00.830
And therefore, let me show you how you could set up a testing environment for MongoDB, where you use

02:00.830 --> 02:03.980
a dedicated testing database because that's important.

02:03.980 --> 02:08.750
You definitely don't want to use your production database for testing.

02:08.750 --> 02:14.660
You don't want to mess with your user data for testing and accidentally delete it or anything like that.

02:15.650 --> 02:22.880
So let's actually create a new test here still related to the off controller before we finish up this

02:22.880 --> 02:25.080
module with the feed controller later.

02:25.100 --> 02:29.690
So still related to the off controller and we had a look at log in.

02:29.690 --> 02:35.260
Obviously, there is more we could test, but let's now move on to the get user status method.

02:35.270 --> 02:39.170
You're actually to to get user status controller action there.

02:39.170 --> 02:44.510
We're finding a user by ID and therefore will need to make sure that our testing database has such a

02:44.510 --> 02:45.140
user.

02:45.470 --> 02:50.600
And we then just want to make sure that let's say we could of course also test that we don't find a

02:50.600 --> 02:53.660
user for ID and test for an ID that does not exist.

02:53.660 --> 02:57.590
But let's also say we want to test for an ID that does exist.

02:57.590 --> 03:05.900
Then we just want to make sure that we actually don't return an error, but that we instead return a

03:05.900 --> 03:10.160
response where our user status is set.

03:10.580 --> 03:12.170
That could be a test we want to write.

03:12.170 --> 03:17.420
So back in the off controller, I'll add a new test case and give it a description of it.

03:17.420 --> 03:28.190
Should send a response with a valid user status for an existing user, something like that.

03:28.490 --> 03:35.240
Now this again will require that done keyword because we'll again run async code in that test case.

03:35.600 --> 03:41.240
And now inside of that test case, I want to connect to my testing database.

03:41.240 --> 03:46.310
I want to make sure that there is a user in that database, of course, because otherwise I can't retrieve

03:46.310 --> 03:46.880
the user.

03:46.880 --> 03:53.690
Then I want to retrieve it and I want to make sure that I do actually then that my controller action

03:53.690 --> 04:00.650
does correctly retrieve the user status and add it to a response with the status code of 200, let's

04:00.650 --> 04:01.070
say.

04:01.870 --> 04:11.260
Now for that, first of all, we need to connect to the database and this requires us to import mongoose.

04:11.680 --> 04:17.680
So let's require Mongoose here and set up a connection down there in this test case.

04:17.680 --> 04:22.050
And I'll show you a different way of doing this on a per test case basis soon.

04:22.060 --> 04:25.050
But for now, let's do it here by calling.

04:25.060 --> 04:25.330
Whoops.

04:25.360 --> 04:26.830
Not disconnect, but connect.

04:26.830 --> 04:29.470
And now you need your connection string.

04:29.470 --> 04:34.590
And for that you can generally use the same connection string used before an app args.

04:34.600 --> 04:40.510
So this connection string here, you can use that and actually of course you could.

04:41.620 --> 04:45.100
Copy this entire code here, even into your off controller.

04:45.370 --> 04:46.510
Add it like this.

04:47.560 --> 04:50.230
Now just need to adjust some things.

04:50.560 --> 04:54.430
I changed that password for that user in the meantime, so I'll paste that in.

04:54.430 --> 04:58.960
And now important the database to which you're connecting there should be a testing database, so I'll

04:58.960 --> 05:02.220
name it test messages here and that's super important.

05:02.230 --> 05:04.150
Don't use the production database.

05:05.080 --> 05:10.750
Now of course we don't call app listen when we are successful, but instead here we now can continue

05:10.750 --> 05:12.370
setting up our test.

05:12.670 --> 05:18.010
And again, I will show you a more elegant way of doing this, all in this nested manner later.

05:18.610 --> 05:24.400
So here I now want to define my my testing logic.

05:24.550 --> 05:29.200
And my testing logic here, of course, is that, first of all, I need a dummy user.

05:29.530 --> 05:33.130
So I'll create a user with new user.

05:33.130 --> 05:34.750
User is already imported.

05:35.410 --> 05:42.280
And that user which gets created here, of course, has to be created as we do it in our user model

05:42.280 --> 05:48.460
or as we define it here with the email, a password, a name status does not need to be set because

05:48.460 --> 05:53.560
there is a default of I am new for which we then should check later and post array.

05:53.560 --> 05:57.820
So email, password, name and post is what should be set here.

05:58.510 --> 06:01.300
Email could be test at test dot com.

06:01.390 --> 06:05.980
Password can be tester and of course no hashed password.

06:05.980 --> 06:07.900
But this is all just a testing setup.

06:09.030 --> 06:16.080
The name could be test and the post array can be empty here and status again doesn't have to be set

06:16.080 --> 06:18.150
because there is a default defined.

06:18.330 --> 06:24.300
Then we call save and I return this because this will all return a promise so we can now add another

06:24.330 --> 06:25.230
then block.

06:25.620 --> 06:31.170
In this function here we now have the dummy user set up and saved to the database.
