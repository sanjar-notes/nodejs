WEBVTT

00:02.110 --> 00:09.640
Now I cleared the play case file again because to conclude this quick refresher module, I'll dive into

00:09.640 --> 00:15.220
another core concept, and that is how to work with a synchronous code.

00:15.310 --> 00:20.350
And for that, we first of all have to understand what asynchronous code is.

00:20.470 --> 00:25.900
Let's say I set a timer with set timeout, which is a function built into Node.js.

00:26.320 --> 00:31.630
There we define a function that should execute after a certain timer expired.

00:31.660 --> 00:33.730
Here, I'll use an arrow function.

00:33.730 --> 00:36.280
You could use a named function, whatever you like.

00:36.970 --> 00:38.650
The second argument is the timer.

00:38.650 --> 00:39.940
Let's say 2 seconds.

00:39.940 --> 00:41.740
You express it in milliseconds.

00:41.740 --> 00:46.420
So 2 seconds are 2000 milliseconds in their.

00:47.440 --> 00:49.870
I'll simply log timer is done.

00:52.590 --> 00:58.650
If I now run this file for 2 seconds, nothing happens and then we see timer is done.

00:59.160 --> 01:05.040
Now this is asynchronous code because it doesn't finish immediately and it would even be a sin code

01:05.040 --> 01:06.690
if we had one milliseconds there.

01:06.690 --> 01:15.570
So if it's super fast, it does not happen immediately in our code snippets like if we have console.log.

01:16.480 --> 01:17.320
Hello.

01:18.870 --> 01:20.670
And console.log.

01:22.340 --> 01:23.180
Hi.

01:23.660 --> 01:28.550
These two snippets are synchronous code because they are executed right after each other.

01:28.550 --> 01:34.640
And yeah, technically of course it will take some time to execute them, but there is no delay other

01:34.640 --> 01:36.800
than your hardware, so to say.

01:37.190 --> 01:44.030
And therefore this is synchronous code, this is async code, asynchronous, because it does not execute

01:44.030 --> 01:45.200
or finish immediately.

01:45.200 --> 01:48.140
It takes a little time, even if that's super short.

01:48.830 --> 01:53.540
And indeed, if I execute this file like this, you see, hello and hi.

01:53.540 --> 02:00.830
Before you see timer is done, even though it's super fast because Node.js and JavaScript in general

02:01.010 --> 02:05.870
does not block your code execution until that is done.

02:06.080 --> 02:11.780
Indeed, here it will recognize this so called callback function.

02:11.780 --> 02:14.390
So a function should execute in the future.

02:14.390 --> 02:18.140
It should call back later once it is done.

02:18.140 --> 02:24.500
So once this timer expired here, it will just recognize that and will then immediately move on to the

02:24.500 --> 02:32.120
next line and will execute all the synchronous code and then execute your async code once this is done.

02:32.120 --> 02:38.030
Which is why we see how low and high first, even though in our code time is done, is printed first,

02:38.030 --> 02:44.510
and that is a crucial concept you have to understand in JavaScript and especially Node and I will come

02:44.510 --> 02:47.300
back to that throughout the course because it's so important.

02:48.310 --> 02:54.430
Now when working with that and I'll increase this to 2 seconds again to make it even clearer, then

02:54.430 --> 02:59.230
you will see again our sync code runs and then after 2 seconds this code runs.

02:59.410 --> 03:05.590
When working with async code, we get multiple techniques of well handling it.

03:06.130 --> 03:12.520
The callback function is one, the oldest one, and you'll see it quite a bit, especially in Node.js.

03:12.550 --> 03:20.590
There's nothing wrong with it, but you'll face a problem if you have a couple of depending async operations.

03:20.830 --> 03:27.460
So here we set the timer and now let's say I create another function.

03:29.830 --> 03:32.500
Which I'll name fetch data.

03:34.280 --> 03:40.520
And in there I will also just set a timer because I don't want to set up some data base or something

03:40.520 --> 03:40.880
like that.

03:40.880 --> 03:43.650
Where we fetch data from will do all that throughout the course.

03:43.670 --> 03:44.780
Of course, no worries.

03:45.080 --> 03:51.500
So here again, I have another timer in there which takes like one and a half seconds.

03:54.480 --> 03:56.970
And now here in fetch data.

03:57.000 --> 04:03.090
I need some way of well, doing something when this inner timer is done.

04:03.090 --> 04:08.790
So here I will actually expect an argument which I'll name callback, because this argument will be

04:08.790 --> 04:09.570
a function.

04:09.570 --> 04:12.660
I will eventually call in my inner function here.

04:12.660 --> 04:19.950
Once I'm done with the timer there, I can pass done as a value now in the place where I use fetch data.

04:19.950 --> 04:23.160
Let's say that's inside of this set timeout call.

04:24.050 --> 04:25.740
I call fetch data like this.

04:25.760 --> 04:26.330
There.

04:26.330 --> 04:28.940
I now need to pass another callback.

04:29.360 --> 04:30.320
And here.

04:31.130 --> 04:35.960
I will get the text passed by the callback in my function when I execute it.

04:35.960 --> 04:40.730
So we'll get some text here and icon console.log that text.

04:41.390 --> 04:46.940
Now this might look confusing in the end here I'm creating my own function, which gets a callback so

04:46.940 --> 04:52.550
that I can define a function which should execute once this inner timer is done from some other place.

04:52.550 --> 04:57.710
So from this place here, this is the function which effectively is passed in as a callback, and I'm

04:57.710 --> 04:59.240
executing that function here.

04:59.750 --> 05:02.240
Now, if I save that and I run that.

05:03.170 --> 05:04.780
It takes 2 seconds.

05:04.800 --> 05:06.270
Then it's trial time or it's done.

05:06.270 --> 05:08.550
And then after one and a half seconds, I see done.

05:08.850 --> 05:16.800
Now, if we have a couple of nested async calls, as we have here, we go deeper and deeper from a callback

05:16.800 --> 05:17.790
perspective.

05:18.210 --> 05:24.570
And that is why we also have a feature called Promises, which we can use Node.js.

05:24.960 --> 05:29.490
Now often we'll use third party packages that already use promises for us.

05:29.790 --> 05:34.590
So the syntax I'll show you now is one you really have to write on your own.

05:34.680 --> 05:37.650
That will be done by the packages behind the scenes.

05:37.740 --> 05:41.460
Still nice to know you create a promise.

05:42.440 --> 05:45.290
Inside of our fetch data function here, let's say.

05:48.120 --> 05:53.490
By storing it in a constant or variable, and then by using the new keyword which you use in JavaScript

05:53.490 --> 05:56.290
to create a new object based on a constructor.

05:56.310 --> 06:00.460
If constructor functions are something that tells you nothing.

06:00.480 --> 06:07.500
Check out some basic introduction resource to JavaScript because constructor functions are a core feature

06:07.500 --> 06:08.550
in JavaScript.

06:08.970 --> 06:15.240
And here you use the Promise constructor function which is built into JavaScript and Node.js.

06:16.280 --> 06:22.160
And this actually also takes a callback which gets to arguments, resolve and rechecked.

06:22.170 --> 06:27.920
You could name them however you want, but these are two functions and the first one completes the promise

06:27.920 --> 06:28.850
successfully.

06:28.850 --> 06:34.820
It resolves it successfully, the second one rejects it, which is like throwing an error.

06:35.390 --> 06:40.880
You then take your async code and move that into there and again, you really have to write this on

06:40.880 --> 06:41.390
your own.

06:41.390 --> 06:46.850
Most packages already do that for you and give you the finished promise, which does all the magic behind

06:46.850 --> 06:48.770
the scenes hidden away from you.

06:48.800 --> 06:50.330
Here we do it manually.

06:50.420 --> 06:55.160
So now in that callback we have our own function set.

06:55.160 --> 06:58.460
Timeout does not give us a promise API unfortunately.

06:58.460 --> 07:00.470
So here we also have to use a callback.

07:00.710 --> 07:01.910
But in there.

07:03.520 --> 07:08.310
We now know no longer use any callback function we get.

07:08.320 --> 07:10.840
I get no argument here in fetch data anymore.

07:10.990 --> 07:20.980
Instead here I resolve done let's say so I successfully return to resolve value now in fetch data after

07:20.980 --> 07:24.190
defining the promise, we just have to return it.

07:24.490 --> 07:27.490
And please note this is synchronous code.

07:27.490 --> 07:33.370
So actually this will be returned immediately after the promise gets created, before the code in the

07:33.370 --> 07:39.790
promise is run, which will happen sometime later when we actually call that function and when this

07:39.790 --> 07:41.200
timer then completes.

07:41.470 --> 07:46.360
So we now return that promise here and in the place where we call fetch data.

07:46.480 --> 07:54.700
We now no longer pass a callback, but we can now use then which is callable on a promise and we return

07:54.700 --> 07:55.540
a promise.

07:56.740 --> 08:03.370
And this simply allows us to now define the callback function here, which will execute once the promise

08:03.370 --> 08:04.450
is resolved.

08:07.420 --> 08:07.660
Now.

08:07.660 --> 08:09.250
What is the advantage of that?

08:09.700 --> 08:12.070
If we had multiple such promises.

08:13.250 --> 08:20.180
So let's say I call fetch data again in there then I don't have to use then like this.

08:21.070 --> 08:24.310
And therefore I would end up with nested.

08:25.480 --> 08:26.800
Callbacks again.

08:27.560 --> 08:30.230
But instead inside of a promise.

08:30.380 --> 08:35.210
And then block is part of a promise I can trust.

08:35.210 --> 08:42.830
Return a new promise and then add the next then block after the previous one.

08:46.260 --> 08:47.190
Like this.

08:47.430 --> 08:50.280
So now we have a chain of then blocks.

08:50.310 --> 08:55.820
This one gets called on the first promise, then in the then block, I return another promise.

08:55.830 --> 09:01.830
And even if that would not give us a promise, instead of a then block returning, it would convert

09:01.830 --> 09:04.290
it to a promise that instantly resolves.

09:04.440 --> 09:10.500
And then we add another then block, which is now referring to this promise here, and this is more

09:10.500 --> 09:14.190
readable than having infinitely nested callbacks.

09:14.640 --> 09:16.380
So now if I run that, we see.

09:16.380 --> 09:16.710
Hello.

09:16.710 --> 09:17.310
Hi.

09:17.340 --> 09:18.660
The timer is done.

09:18.840 --> 09:23.070
We are done and we see done again because I'm calling fetch data twice.

09:23.640 --> 09:27.810
So this might be difficult to wrap your head around for the first time.

09:27.810 --> 09:32.430
We will reuse it throughout this course and then it will become clearer again.

09:32.520 --> 09:41.160
This code is mostly not written by you, but it is a crucial concept that makes our async code more

09:41.160 --> 09:42.180
manageable.

09:42.570 --> 09:49.800
There always is another way of managing this async await to special keywords you can use in modern JavaScript,

09:49.800 --> 09:53.310
and I'll have a separate section about this towards the end of the course.

09:53.310 --> 09:59.010
I don't want to introduce it here because it can actually be more confusing than this syntax here.

09:59.010 --> 10:04.290
And I want to stick to this one to not introduce too many new features at the same time here.

10:04.950 --> 10:10.080
Async code is something you have to understand though, and if it's not totally clear by now, that

10:10.080 --> 10:16.050
is fine though you will see it throughout the course a bunch because we have a lot of asynchronous events

10:16.050 --> 10:20.190
in Node.js and I will explain this multiple times.

10:20.190 --> 10:22.020
I'll also explain promises.

10:22.020 --> 10:28.740
Again, I just want to ensure that you have seen this by now and that you then have a chance of understanding

10:28.740 --> 10:31.410
this, how it works and how we deal with it.
