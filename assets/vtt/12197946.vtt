WEBVTT

00:02.360 --> 00:05.540
The basic create post mutation is in place

00:05.590 --> 00:12.580
but now we need to be able to validate our token and extract the user from it and that is not too far

00:12.580 --> 00:16.070
off on how we did it in a rest API.

00:16.870 --> 00:25.150
First of all, we need to ensure that we send the token in a header of our incoming request and if we have

00:25.150 --> 00:31.030
a look at our frontend code and there at feed.js which is where we do create new posts, we do that

00:31.030 --> 00:34.360
in the finish edit hÃ¤ndler, there

00:34.360 --> 00:41.100
we do indeed attach our token to the outgoing request

00:41.160 --> 00:45.790
and this is still the wrong url here but this is how we will send the request in the end.

00:46.050 --> 00:47.780
So we'll have that token

00:47.790 --> 00:54.770
in the url and previously in the rest API, we use isAuth middleware to get our token from there,

00:54.870 --> 01:01.380
validated, extract the user data and add the user data, the user ID to the request object

01:01.380 --> 01:03.320
and that is pretty close to what I want to do

01:03.320 --> 01:06.380
now. I will just tweak it a little bit,

01:06.420 --> 01:10.320
I'll name it auth because it's not just there to validate authentication,

01:10.320 --> 01:16.640
it will also give me the user data but that is something purely cosmetic. In there

01:16.640 --> 01:20.500
I will still first of all get my auth header,

01:20.660 --> 01:27.480
I'll check if it is set and if it is not set, then I will do something different though, I will not throw

01:27.480 --> 01:30.180
an error, instead on my request

01:30.180 --> 01:35.840
I'll set isAuth to false so that I can handle this inside of my resolvers

01:36.120 --> 01:42.360
and then I will return next to continue with the next middleware and not execute the other code here,

01:42.360 --> 01:44.890
that is why I also have the return statement.

01:45.090 --> 01:51.990
If we do have the auth header, we continue, we extract the token as before, we try to decode it just as

01:51.990 --> 01:52.810
before,

01:52.830 --> 01:59.170
make sure this key here matches the key you used in your resolver for signing the token by the way,

01:59.190 --> 02:03.450
if these two don't match, you have no chance of validating your token.

02:03.590 --> 02:07.740
We catch an error but if I get an error, I again don't throw it,

02:07.740 --> 02:15.440
instead I set request isAuth to false and return next here too to not execute any other code.

02:15.780 --> 02:17.960
If the decoded token is undefined,

02:18.030 --> 02:20.430
I also throw no error, instead

02:20.430 --> 02:31.340
here again I set isAuth to false and I return next. And if I make it past all these checks, I will get my

02:31.340 --> 02:35.420
user ID from the decoded token and I will set isAuth to true,

02:35.420 --> 02:39.800
so that is a new property I add to the request and I call next.

02:40.190 --> 02:43.680
Now this tweak middleware is something I add in app.js

02:43.710 --> 02:47.480
before my graphql endpoint.

02:47.840 --> 02:57.670
So here, I will simply import that auth by requiring it from middleware auth,

02:57.670 --> 03:07.780
this is my middleware and I will add it here like that. This middleware will now run on every request that

03:07.780 --> 03:11.830
reaches my graphql endpoint but it will not deny the request

03:11.830 --> 03:17.950
if there is no token, the only thing it will do is it will set isAuth to false and then I can decide in

03:17.950 --> 03:25.200
my resolver whether I want to continue or not and this is the next step. In my resolvers there,

03:25.420 --> 03:28.290
I don't care about isAuth in create user and so on,

03:28.330 --> 03:33.850
so there I will just not do anything with that information. In create post here,

03:34.120 --> 03:37.840
I will first of all check if request isAuth,

03:37.870 --> 03:42.940
if that is not true because then I know hey the user is not authenticated,

03:43.030 --> 03:50.440
I certainly don't want to grant access to creating a post. So if the user is not authenticated here, then

03:50.440 --> 03:55.690
I will create a new error, not authenticated

04:00.820 --> 04:07.750
and I'll set my code of let's say 401 and then I'll throw my error and therefore the other code

04:07.780 --> 04:11.480
in this resolver here will not execute.

04:11.870 --> 04:17.310
If the user is authenticated, we can continue and then we validate the input and then before we create the

04:17.310 --> 04:24.510
post, we can now also get the user from the database because remember that we do store the user id in

04:24.510 --> 04:34.760
our request as well. So in the resolver right before creating the post now, I can get my user by awaiting

04:34.760 --> 04:38.980
user find one or not find one,

04:38.980 --> 04:45.730
I can actually use find by ID of course and there I pass in request user id, so exactly the thing

04:45.910 --> 04:46.950
I'm storing here.

04:49.190 --> 05:00.270
I passed it in and now I get a user. If I don't get a user here, then something is wrong and I will throw

05:00.420 --> 05:01.440
an error,

05:01.450 --> 05:09.200
so here invalid user maybe, set the code to 401 and throw that

05:09.250 --> 05:13.230
but if we make it past that, we have a user object with which we can work.

05:13.450 --> 05:19.410
And now in the newly created post, I can set the creator equal to my extracted user,

05:19.510 --> 05:21.640
so to the user I got from the database.

05:24.370 --> 05:32.260
Once I created the post, I can now also use that user and access the posts of that user to push the created

05:32.260 --> 05:34.990
post onto that list of posts,

05:34.990 --> 05:38.880
so to set up that connection. That is now it

05:38.960 --> 05:45.080
and now we need to work on the frontend to also send a request to this endpoint so that we can see

05:45.110 --> 05:46.160
that in action.
