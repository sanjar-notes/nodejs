WEBVTT

00:02.180 --> 00:08.370
Over the last lectures, I extensively mentioned how node works with asynchronous code

00:08.390 --> 00:11.610
and i mentioned this event loop which is important.

00:11.720 --> 00:16.070
Let me dive deeper into that and deeper into how

00:16.060 --> 00:24.380
nodejs exactly executes your code to stay performant and still be able to handle long taking tasks

00:24.560 --> 00:29.360
like working with files or things like that because there is an important concept which you have to

00:29.360 --> 00:34.100
understand to understand, well what is happening behind the scenes.

00:34.100 --> 00:37.250
So in our node application we have our code

00:37.280 --> 00:44.420
and one important thing to understand and to really keep in mind is that nodejs uses only one single

00:44.450 --> 00:46.100
javascript thread,

00:46.460 --> 00:50.710
a thread is basically like a process in your operating system you could say.

00:50.900 --> 00:57.380
So it's only using that one thread and the obvious question is how is it then able to handle multiple

00:57.380 --> 01:05.390
requests because if we're not able to assign a new thread for each request, they ultimately end up all

01:05.390 --> 01:07.390
running in one on the same thread

01:07.430 --> 01:10.310
and this of course poses a security question,

01:10.310 --> 01:17.990
can you then access data from request A, from request B and most importantly here at this point when

01:17.990 --> 01:23.930
we talk about performance, there of course also is the question of does this not mean that if the

01:23.930 --> 01:30.480
request A is still doing work, request B can't be handled? Well both is taken care of

01:30.500 --> 01:30.840
nodejs

01:30.890 --> 01:31.470
.

01:31.550 --> 01:37.340
and at this point of time here, I want to focus on the performance question though I'll also briefly

01:37.340 --> 01:39.150
touch on the security question.

01:39.290 --> 01:41.510
Now let's start with the performance.

01:41.510 --> 01:49.100
Let's say we have some code which accesses the file system as we already did in this course too. Now working

01:49.100 --> 01:55.670
with files often is a task that takes longer because files can be very big and it doesn't necessarily

01:55.670 --> 01:57.380
complete instantly,

01:57.620 --> 02:03.950
therefore if we're doing this upon an incoming request, a second request might have to wait because we're

02:03.950 --> 02:07.070
not able to handle it yet or it even gets declined,

02:07.070 --> 02:11.270
so basically our webpage is down for that user.

02:11.270 --> 02:17.780
Now one important construct I already mentioned is that event loop, the event loop is automatically started

02:17.780 --> 02:20.580
by nodejs when your program starts,

02:20.600 --> 02:22.830
you don't have to do that explicitly,

02:22.880 --> 02:24.810
nodejs does that when well

02:24.860 --> 02:27.380
it basically starts running code.

02:27.620 --> 02:31.970
This is responsible for handling event callbacks though,

02:32.090 --> 02:39.260
so all these nice functions we basically added thus far in create server for example, the event loop

02:39.290 --> 02:45.830
is responsible for basically running that code when a certain event occurs you could say, it's aware

02:45.830 --> 02:52.520
of all these callbacks and basically well, execute said code. That doesn't help us with our long taking

02:52.520 --> 02:59.330
file operation though and it's important to understand that this operation is not handled by the event

02:59.330 --> 03:04.890
loop, just the callback that we might have defined on write file

03:04.940 --> 03:11.150
once it's done, that code will be handled in event loop but that code will finish fast,

03:11.150 --> 03:17.950
so basically the event loop will only handle callbacks that contain fast finishing code.

03:18.710 --> 03:25.370
Instead our file system operation and a couple of other long taking operations are sent to a worker

03:25.400 --> 03:29.810
pool which is also spun up and managed by nodejs automatically.

03:30.180 --> 03:34.450
This worker pool is responsible for all the heavy lifting,

03:34.650 --> 03:42.450
this worker pool is kind of totally detached of your javascript code you could say and it runs on different

03:42.450 --> 03:47.990
threads, it can spin up multiple threads, it's closely intervened with your operating system you're

03:47.990 --> 03:49.200
running the app on,

03:49.220 --> 03:55.560
so this is really detached from your code and this worker pool is therefore doing all the heavy lifting.

03:55.640 --> 04:01.710
If you're doing something with a file, well a worker from that pool will take care and will do its job

04:01.760 --> 04:09.000
totally detached from your code and from the request and from the event loop. The one connection to the event loop

04:09.020 --> 04:11.360
we will have though is that

04:11.390 --> 04:19.550
once the worker is done, so for example once we read a file, it will trigger the callback for that read

04:19.550 --> 04:25.460
file operation and since the event loop is responsible for the events and the callbacks, this will in

04:25.460 --> 04:28.100
the end end up in the event loop,

04:28.100 --> 04:33.560
so there nodejs will then basically execute the appropriate callback.

04:33.560 --> 04:39.050
Now this is a lot of behind the scenes stuff which is nice to know, you don't have to write any code

04:39.350 --> 04:40.360
to make this work,

04:40.360 --> 04:42.620
this is all built into nodejs

04:42.650 --> 04:47.810
and if you write code as you learn it in this course, you automatically take advantage of this.

04:47.840 --> 04:53.210
I still of course want you to understand how that works behind the scenes because I believe that helps

04:53.210 --> 04:54.100
you understand

04:54.110 --> 04:56.060
nodejs better.

04:56.060 --> 04:57.610
Now let's look into that event loop

04:57.620 --> 05:00.710
then. That event loop is in the end

05:00.710 --> 05:07.570
a loop which is run or started by nodejs that keeps the nodejs process running

05:07.650 --> 05:14.060
and as I just mentioned, that handles all the callbacks and it has a certain order in which it goes through

05:14.160 --> 05:15.300
the callbacks.

05:15.690 --> 05:19.250
So basically it's a loop that just well keeps on looping

05:19.290 --> 05:25.650
unsurprisingly, at the beginning of each new iteration it checks if there are any timer callbacks it

05:25.650 --> 05:29.410
should execute. We haven't set up any timers yet

05:29.590 --> 05:32.840
but basically there is set timeout and set interval,

05:32.860 --> 05:39.760
you might know this from frontend javascript too, there these methods also exist. Now in nodejs you can

05:39.760 --> 05:47.040
also set a timer and basically you set a timer and always pass a method, a function that should be executed

05:47.080 --> 05:52.840
once that timer completes and nodejs is aware of this and at the beginning of each new loop iteration,

05:53.170 --> 05:56.020
it executes any due timer callbacks,

05:56.020 --> 06:02.740
so any callbacks that have to be executed because a timer completes. Then as a next step, it checks other

06:02.740 --> 06:03.520
callbacks,

06:03.550 --> 06:10.240
for example if we had write or read file, we might have a callback because that operation finished and

06:10.240 --> 06:13.600
it will then also execute these callbacks.

06:13.630 --> 06:21.340
Now be aware that with IO here, I mean generally any input output operations that typically is file

06:21.340 --> 06:27.370
operations but can also be network operations and in general, I'm talking about blocking long taking

06:27.370 --> 06:28.730
operations.

06:28.750 --> 06:34.540
Now it's important to understand that nodejs will leave that phase at a certain point of time and that

06:34.540 --> 06:40.900
can also mean that if there are too many outstanding callbacks, it will continue its loop iteration and

06:40.900 --> 06:48.910
postpone these callbacks to the next iteration to execute them. After working on these open callbacks

06:48.940 --> 06:50.930
and hopefully finishing them all,

06:50.980 --> 07:00.310
it will enter a pull phase. The pull phase is basically a phase where nodejs will look for new IO events

07:00.340 --> 07:07.000
and basically do its best to execute their callbacks immediately if possible.

07:07.000 --> 07:14.440
Now if that's not possible, it will defer the execution and basically register this as a pending callback,

07:14.470 --> 07:16.160
so this is how that works.

07:17.220 --> 07:23.970
Important, it also will check if there are any timer callbacks due to be executed

07:24.030 --> 07:29.010
and if that is the case, it will jump to that timer phase and execute them right away,

07:29.070 --> 07:32.510
so it can actually jump back there and not finish the iteration

07:32.640 --> 07:34.150
otherwise it will continue

07:34.350 --> 07:42.030
and next set immediate callbacks will be executed in a so-called check phase. Set immediate is a bit like

07:42.030 --> 07:50.000
set timeout or set interval, just that it will execute immediately but always after any open callbacks

07:50.070 --> 07:51.750
have been executed,

07:51.870 --> 07:58.140
so typically faster than set timeout with one millisecond of open duration, let's say

07:58.230 --> 08:01.450
but after the current cycle

08:01.620 --> 08:06.750
well finished or at least finished open callbacks that were due to be handled in that current iteration.

08:06.960 --> 08:09.770
And now we're entering a highly theoretical terrain

08:09.900 --> 08:15.780
and I don't want to dive too deep into that, though you will find a couple of resources that do dive

08:15.780 --> 08:21.600
deeper at the end of this module in case you want to join the nodejs team and really dive super

08:21.600 --> 08:23.270
hardcore into this.

08:23.490 --> 08:30.510
Now we're nearing the end of each iteration cycle and now nodejs will execute all close event callbacks,

08:30.510 --> 08:34.860
so if you registered any close events and in our code, we haven't

08:34.920 --> 08:40.890
but if you had any close events, this would be the point of time where nodejs executes their appropriate

08:40.890 --> 08:41.940
callbacks.

08:42.120 --> 08:49.290
So roughly spoken, we have timer callbacks, we then have any IO related callbacks and other event callbacks

08:49.650 --> 08:53.470
and set immediate followed by close event callbacks,

08:53.520 --> 08:58.830
so close events are basically handled separately or their callbacks are handled separately we should

08:58.830 --> 09:09.750
say. Well and then we might exit the whole nodejs program but only if there are no remaining event

09:09.840 --> 09:17.150
handlers which are registered and that is what I mean with this refs equal null thing here. Internally

09:17.180 --> 09:25.050
nodejs keeps track of its open event listeners and it basically has a counter, references or refs

09:25.260 --> 09:30.000
which it increments by 1 for every new callback that is registered,

09:30.000 --> 09:32.760
every new event listener that is registered

09:32.850 --> 09:35.630
so every new future work that it has to do

09:35.630 --> 09:41.460
you could say and it reduces that counter by 1 for every event listener that it doesn't need anymore,

09:41.640 --> 09:47.280
every callback it finished and since in a server environment

09:47.280 --> 09:53.370
we create a server with create server and then listen to incoming requests with listen,

09:53.460 --> 09:59.820
this is an event which never is finished by default and therefore, we always have at least one reference

10:00.000 --> 10:06.630
and therefore we don't exit in a normal node web server program. We can call the exit function as you

10:06.630 --> 10:07.720
already saw

10:07.950 --> 10:14.070
and if we do anything else like at the beginning of the course when we just used node to execute a file

10:14.070 --> 10:21.270
that did not listen to a web server or on a web server, then it also finishes eventually once its done

10:21.360 --> 10:23.150
with its work.

10:23.160 --> 10:25.340
So this is how the event loop works

10:25.740 --> 10:34.110
and this can be very theoretical, all these different phases typically don't matter to you, certainly

10:34.110 --> 10:36.650
not when getting started with nodejs.

10:36.780 --> 10:40.930
Now consult these advanced resources if you want to learn more,

10:40.950 --> 10:48.660
for now just be aware of that first picture I showed you, of how nodejs handles complex work, that

10:48.660 --> 10:54.270
there is this worker pool that takes care that your things are not getting blocked and that it therefore

10:54.270 --> 10:56.280
stays performant.

10:56.280 --> 11:02.110
Now I also touched on that security thing with that one javascript thread

11:02.350 --> 11:06.340
and regarding that, we also got no problems by default,

11:06.480 --> 11:13.920
though I will come back later to how we can manage global data and how we should manage it to ensure

11:13.920 --> 11:19.050
that we do not spoil data from request A to request B. By default

11:19.050 --> 11:25.350
we have some separation because remember that callback method in create server gets executed for every

11:25.350 --> 11:31.080
new incoming request and therefore this function only runs for that incoming request and anything we do

11:31.080 --> 11:36.900
to the request or response object there will not be exposed to our request or response objects because

11:36.900 --> 11:42.100
each function is only scoped to itself and not accessible by the other functions,

11:42.120 --> 11:47.760
so by default we have that separation due to how javascript works.

11:47.760 --> 11:50.130
Now that was a big chunk of theory,

11:50.130 --> 11:55.200
again not something you have to learn by heart but something where you should at least keep that big

11:55.200 --> 11:58.910
picture in mind of how nodejs manages its work.
