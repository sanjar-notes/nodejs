WEBVTT

00:02.140 --> 00:09.340
We already achieved a lot in this section, and I know that all this code looks kind of intimidating

00:09.340 --> 00:10.490
and no worries.

00:10.510 --> 00:16.750
It will become much easier, but I find it super important to learn it the hard way first so that you

00:16.750 --> 00:20.050
never forget what's happening behind the scenes.

00:20.560 --> 00:27.760
Now, one crucial thing which I know that people often struggle with is that the order of execution

00:27.760 --> 00:32.230
of your code here is not necessarily the order in which you write it.

00:32.260 --> 00:41.500
For example, this here will actually execute after this code, so it will even execute after we already

00:41.500 --> 00:42.790
sent a response.

00:43.060 --> 00:45.370
This has two important implications.

00:45.370 --> 00:51.170
For one, sending the response does not mean that our event listeners here are dead.

00:51.190 --> 00:55.000
They will still execute, even if the response is already gone.

00:55.000 --> 01:00.640
But it also means that if we do something in the event listener that should influence in the response,

01:00.640 --> 01:02.450
this is the wrong way of setting it up.

01:02.470 --> 01:07.840
We should then also move the response code into the event listener if we had such a dependency.

01:08.380 --> 01:16.750
But it also means that it's super important to understand that with request on or code like HTTP create

01:16.750 --> 01:17.440
server.

01:17.470 --> 01:26.050
These are some examples where no case uses a pattern where you pass a function to a function and node

01:26.050 --> 01:32.980
will execute these past in functions at a later point of time, which is called asynchronously.

01:33.010 --> 01:38.980
Now, it's not always the case that a past in function is necessarily executed at a later point of time.

01:38.980 --> 01:42.730
But no case uses this pattern heavily and throughout the course.

01:42.730 --> 01:48.760
I'll, of course, let you know when this is the case and when Node executes something asynchronously.

01:50.160 --> 01:56.320
In such cases, no charges won't immediately run that function.

01:56.340 --> 02:03.270
Instead, what it does when it first encounters this line is it will simply add a new event listener

02:03.270 --> 02:04.130
internally.

02:04.140 --> 02:06.630
It manages all these listeners internally.

02:06.720 --> 02:12.740
In this case, for the end event on the request, which will be triggered automatically once no chars

02:12.750 --> 02:14.610
is done parsing the request.

02:14.610 --> 02:17.130
So this is something no trace does for you.

02:17.990 --> 02:22.140
And it will then call that function for you once it is done.

02:22.160 --> 02:28.850
So in the end, you can think of this like no charge as having some internal registry of events and

02:28.850 --> 02:30.260
listeners to these events.

02:30.260 --> 02:36.050
And a function like this is such a listener and when sort of something happens, so when Node.js is

02:36.050 --> 02:43.220
done parsing your request, it will go through that registry and see I'm done with the request, so

02:43.220 --> 02:45.290
I should now send the end event.

02:45.290 --> 02:48.560
So let's see which listeners I have for that.

02:48.560 --> 02:54.530
And it will then find this function and any other functions you might have registered for that and will

02:54.530 --> 02:55.730
now call them.

02:56.030 --> 03:01.970
But it will not pause the other code execution and that is so important to understand.

03:02.210 --> 03:09.860
So for example, here now since I moved return response and into this function, the flow is like this.

03:09.860 --> 03:15.080
It will now reach this if statement and if these conditions are met, it will go inside of it.

03:15.750 --> 03:21.380
It will then register these two handlers and not immediately execute these two functions.

03:21.390 --> 03:27.810
Instead, the functions are just registered internally in its event emitter registry and then it will

03:27.810 --> 03:30.780
jump straight away to the next line.

03:31.080 --> 03:37.260
And therefore right now if I would restart my server, save the code and restart my server here.

03:38.530 --> 03:44.890
You will see that if I enter something here, I actually get redirected to this page or not even redirected.

03:44.890 --> 03:47.860
As you can see, there is no 300 status code.

03:47.980 --> 03:54.730
Instead, it just loads this page because it executes these lines because as a now mentioned multiple

03:54.730 --> 04:01.420
times, it will not execute this right away and this return statement will therefore not quit this overarching

04:01.420 --> 04:02.380
function here.

04:02.740 --> 04:09.430
Instead, it just registers this callback and immediately moves on to the next lines and it would eventually

04:09.430 --> 04:10.540
execute this line.

04:10.540 --> 04:16.570
But that is already too late, which is also why we get the cannot set headers error here because it

04:16.570 --> 04:22.330
already moved along and executed this code when all of a sudden the parsing of the request finished

04:22.330 --> 04:27.550
and it executed this code and tried to again send a response which obviously is too late because it

04:27.550 --> 04:28.900
already did here.

04:29.320 --> 04:37.870
Now, I know that this is hard to wrap your head around, but it is a crucial concept that you can register

04:37.870 --> 04:44.500
code functions which run sometime in the future, but not necessarily right now.

04:44.500 --> 04:52.510
And therefore the next line of code, this code here can run or will run before this code, simply because

04:52.510 --> 04:56.770
this is just a callback to be called sometime in the future.

04:56.890 --> 05:04.060
And this setup is important because otherwise node would have to pause until it's done, pause until

05:04.060 --> 05:11.200
it wrote the file, and if it does that, it will simply slow our server down and it's not able to handle

05:11.200 --> 05:15.850
our incoming requests or do anything of that kind until it's done.

05:15.850 --> 05:17.910
And that is not what we want.

05:17.920 --> 05:20.920
We don't want to block our code execution.

05:20.920 --> 05:27.340
We always want to be in that wait for new events, loop the event loop and then only execute code once

05:27.340 --> 05:32.260
it's due to be executed and never block that event loop for too long of a time.

05:32.380 --> 05:39.250
And this is why we have this setup and this has one implication for this line and for this line.

05:39.460 --> 05:42.670
The implication for this line is that we reach it too early.

05:42.670 --> 05:46.510
So to avoid this, we should actually return here.

05:47.230 --> 05:52.720
We simply return requests on so that this gets executed, but the line thereafter doesn't.

05:53.050 --> 05:57.940
And the important application about this line will be discussed in the next lecture.
