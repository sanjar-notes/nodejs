## 537. Using the MongoDB Client Module

<strong><em>no description</em></strong>

<v Instructor>So let's make sure we work with MongoDB.</v> And for that, we set
up this client file, this helpers client file, with a connect and a getDb
function. 

We're calling connect whenever our deno server starts up, and now we wanna call
getDb to get access to the connect database whenever we wanna work with it. 

And as a side note, the MongoClient from the Mongo library will automatically
take care about the connection, it will manage that connection. 

It will even set up multiple simultaneous connections and use a concept called
connection pooling to give us the fastest possible way of working with MongoDB. 

So all of that is taken care of by this Mongo module. 

We just need to call getDb when we now wanna work with the database. 

And of course there are various places where we do wanna work with it. 

One obvious place is when we want to get access to our todos. 

So here in this get todos route, I now I want to call getDb to get access to a
database, and then call collection on that to connect to a specific collection
in that database. 

And since we're the one managing the database, we could expect a todos
collection, the name is up to you, but of course, you should then be consistent
when you connect to that collection. 

So we assume that there will be a todos collection. 

If there won't be, it will be created on the fly by MongoDB. 

And by calling the find method on it, we will actually find all elements in that
todos collection. 

Now find will return a promise. 

So I'll add async here, so that we can await this. 

And what we'll get back here are our todos. 

So we'll get back all the documents that can be found in this collection, and
that will be all our todos. 

Now those todos will be in a specific MongoDB format. 

These will be objects, but objects that in the end will have an _id field, which
will be added automatically by MongoDB, which will be of type ObjectId, a
MongoDB specific type. 

And then they will have a text field, which will be some string. 

So that's how the individual documents here will look like. 

And here we're, of course, getting an array of such documents. 

So to work with those, I want to transform them. 

So my transformed todos will be the todos where I call map. 

And that will execute a function on every todo, and then allows us to transform
every todo into a new object. 

So here we then return this new transformed object. 

And there, let's say, I just want to have a id field, so not _id, but just id,
and that should be our todo._id, but there we can access $oid field. 

Now this might look strange, but this will in the end be a property provided by
the Mongo library on the documents it fetches from MongoDB. 

And that will hold the generated id, generated by MongoDB as a string, and not
as this strange ObjectId object thing here. 

So that will be the string id, which I'll then store in a new id property. 

In addition, there will be a text property, and I wanna keep that, so I'll
simply set text equal to todo.text. 

Now here, we also should assign a type to not have the implicit any type. 

And I'll set the type here to an object type where we'll have an _id field,
which will be of type ObjectId. 

That's now something you can import from the Mongo library. 

So I'll copy that URL into todos.ts, but I'll not import Mongo client or
database, instead, I'll import ObjectId, and this will be a type which we now
can use here. 

And we'll have a text field, which will have a value of type string. 

So that's now the todo type as we get it back from MongoDB out of our database. 

Therefore, that's the type I'm setting on this argument, which will be passed
into this function we pass to map automatically for every todo that is fetched
from our collection. 

Therefore in the end, we'll have to transform todos. 

And those are the todos which should be returned to the client now. 

So that's a lot of code. 

But with that, we should now be able to fetch todos from the database. 

Now in order to see whether that really works, let's also work on the post
route. 

And let's make sure that we can add a new todo. 

For that, here in create we of course create our new todo but now I want to get
access to the database and then here again to the todos collection. 

Of course, here you should use the same collection name as here when you get
todos, otherwise you're adding and fetching to and from different collections,
which will not be a good idea. 

And then here, we can call insertOne, and this will do just what the name
implies, it will insert one new todo. 

Now here actually, since MongoDB will generate an id for us, we no longer need
to generate it on our own. 

So I'll comment this out. 

And I'll just pass in the new todo like this into insertOne. 

Now, of course, since we don't have an id key anymore here, I'll go to my
interface. 

And by adding a question mark after id, I actually make this optional, so that
TypeScript won't complain if we create a todo object without an id. 

So with that change made, we can create this object and we can feed it into
insertOne. 

And now here we can await this action because insertOne will return a promise. 

And this promise will resolve whenever the insertion finished. 

In that case will then thereafter get information about the id that was
autogenerated by MongoDB for the new todo, and they offer now we can manipulate
the new todo here. 

And we can now add the id property on the fly, and set it equal to id, but not
like this. 

Instead, id will be of type ObjectId, and therefore again, we'll be able to
access $oid to get this id as a string. 

That's simply a specific property that exists on the ObjectId type. 

That will then be our new todo. 

So we'll then have our new todo with the text and with the autogenerated id. 

We don't need to add this to our local array anymore, we can get rid of that,
and we still return it however. 

And if we now save all of that, we can quit that backend server and rerun it
with deno run allow net. 

And this will now download the MongoDB package and try to start our server. 

But for me, it crashes. 

Why does this happen? 

Well, under the hood, this Mongo module uses a Rust plugin. 

I mentioned that Deno would be written with Rust, and that the Mongo module in
the end just wraps the Rust Mongo package. 

Now this is something which is actively supported by Deno. 

But it uses a feature built into Deno, which is called plugins. 

So under the hood Deno has a plugin system and the Mongo library uses this
system. 

Now currently, at the point of time I'm recording this, this is only supported
if we add the unstable flag to our execution. 

This might not be the case in the future, but currently it is the case. 

So when we run our app.ts file, we need to add --unstable. 

Even with that, however, it will still fail. 

It now fails with a PermissionDenied error for reading. 

Because it turns out that the Mongo library also wants to read some files. 

So we should also add --allow-read here as a permission, and then try executing
this again. 

But now you see, it also wants write access. 

So let's add this as well, allow-write. 

And with that added, now it's downloading the Mongo library. 

And it crashes with a plugin error, that's the last permission we need to add,
promised, I'm just showing all these errors so that you see that we really need
those permissions. 

The last permission we need to add here is --allow-plugin. 

So you see that this Deno application now needs a lot of permissions already to
run. 

And that's, by the way, all is what I meant earlier. 

We're now granting all those permissions and we're again trusting the Mongo
library, the Mongo module here, that it's not doing anything fishy with those
permissions. 

So we're almost back in the Node world here. 

Nonetheless, I can now hit Enter. 

And now the only error I'm getting is one regarding my URL, we should have a
slash here after MongoDB.net, tiny mistake from my side. 

Let's add this and then try rerunning that. 

And now it should spin up our server successfully, and it should connect to your
MongoDB cluster successfully. 

Assuming you configured that cluster correctly, you whitelisted your local IP,
and you have no firewall in between or anything like that. 

And with that done, let's see whether storing in a database and fetching from a
database works. 

For that, I'll go back to the React application, reload it, and add a new todo,
Learn Deno. 

I click Add Todo, it appears here. 

I get no error on the backend. 

And now if storing in a database worked, I should be able to shut down this
backend Deno server, which I did now, and restart it. 

With that normally, all the data stored in memory will be lost. 

So now if we are still able to fetch that todo, that means that it indeed was
stored in a database. 

So if I now reload, here it is, here it appears, and that means that storing in
a database works, and that we're all able to fetch from it. 

Now, we already spent some time working on the database. 

Let's now make sure that updating and deleting now also works. 

---